
Processing macros.asm

                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* SAVEZP                                   *
                                                  ;*                                          *
                                                  ;*  save a zero page variable               *
                                                  ;*                                          *
                                                  ;*  destroys a, y                           *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro SAVEZP
                                                                  ldy #@3 -1
                                                  -
                                                                  lda @1,y
                                                                  sta @2,y
                                                                  dey
                                                                  bpl -
                                                                  .endm
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* PUSHREG                                  *
                                                  ;*                                          *
                                                  ;*  push registers on the stack             *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro PUSHREG
                                                                  phale
                                                                  tya
                                                                  pha
                                                                  txa
                                                                  pha
                                                                  .endm
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* POPREG                                   *
                                                  ;*                                          *
                                                  ;*  restore registers on the stack          *
                                                  ;*                                          *
                                                  ;*  destroys a,x,y                          *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro POPREG
                                                                  pla
                                                                  txa
                                                                  pla
                                                                  tay
                                                                  pla
                                                                  .endm
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* PUSHAY                                   *
                                                  ;*                                          *
                                                  ;*  push a nd y on the stack                *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro PUSHAY
                                                                  pha
                                                                  tya
                                                                  pha
                                                                  .endm
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* POPAY                                    *
                                                  ;*                                          *
                                                  ;*  restore registers on the stack          *
                                                  ;*                                          *
                                                  ;*  destroys a,y                            *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro POPAY
                                                                  pla
                                                                  tay
                                                                  pla
                                                                  .endm
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* BCD2STR                                  *
                                                  ;*                                          *
                                                  ;*  converts 1 byte bcd to 2 byte string    *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro BCD2STR
                                                                  lda @1                  ;   load the byte to convert
                                                                  and #$F0                ;   get the high nibble
                                                                  lsr                     ;   shift to low nibble
                                                                  lsr
                                                                  lsr
                                                                  lsr
                                                                  ora #'0'                ;   or '0' to make it numeric
                                                                  sta @2                  ;   save the PETASCII low byte
                                                                  lda @1                  ;   reload the byte to convert
                                                                  and #$0F                ;   get the lo nibble
                                                                  ora #'0'                ;   or '0' to make it numeric
                                                                  sta @2 + 1              ;   save the PETASCII high byte
                                                                  .endm
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* MULT10                                   *
                                                  ;*                                          *
                                                  ;*  multiplies 2 byte number by 10          *
                                                  ;                                           *
                                                  ;*  n * 10 = n * 8 + n * 2                  *
                                                  ;*                                          *
                                                  ;*  destroys a,x,y                          *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro MULT10
                                                                  asl @1
                                                                  rol @1 + 1              ;   multiply by 2
                                                  
                                                                  ;
                                                                  ;   save the number * 2
                                                                  ;
                                                                  ldx @1                  ;   save low byte in x
                                                                  ldy @1 + 1              ;   save high byte in y
                                                  
                                                                  ;
                                                                  ;   continue shifting for multiply by 4 and 8
                                                                  ;
                                                                  asl @1
                                                                  rol @1 + 1              ;   multiply by 4
                                                                  asl @1
                                                                  rol @1 + 1              ;   multiply by 8
                                                  
                                                                  ;
                                                                  ;   now add up the result
                                                                  ;
                                                                  clc                     ;   clear carry
                                                                  txa                     ;   load low byte of 2x
                                                                  adc @1                  ;   add to 8x low byte
                                                                  sta @1                  ;   store low byte
                                                                  tya                     ;   load the high byte of 2x
                                                                  adc @1 + 1              ;   add to 8x high
                                                                  sta @1 + 1              ;   store high byte
                                                                  .endm
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  MULT16                                  *
                                                  ;*                                          *
                                                  ;*  16bit multiplication                    *
                                                  ;*                                          *
                                                  ;*  destroys    a,x,y                       *
                                                  ;*                                          *
                                                  ;********************************************
                                                                  .macro MULT16
                                                                  lda @2
                                                                  pha
                                                                  lda @2 + 1
                                                                  pha
                                                                  lda #$00
                                                                  sta @3 + 2              ;   clear upper bits of @3
                                                                  sta @3 + 3
                                                                  ldx #$10                ;   set binary count to 16
                                                  -
                                                                  lsr @2 + 1              ;   divide @2 by 2
                                                                  ror @2
                                                  
                                                                  bcc +                   ;   bcc +  FOWARD  labals dont work yet in macros
                                                                  
                                                                  lda @3 + 2              ;   get upper half of @3 and add @1
                                                                  clc
                                                                  adc @1
                                                                  sta @3 + 2
                                                                  lda @3 + 3
                                                                  adc @1 + 1
                                                  +
                                                                  ror                     ;   rotate partial @3
                                                                  sta @3 + 3
                                                                  ror @3 + 2
                                                                  ror @3 + 1
                                                                  ror @3
                                                                  dex
                                                                  bne -
                                                                  pla
                                                                  sta @2 + 1
                                                                  pla
                                                                  sta @2
                                                                  .endm

Processing pagezero.asm

                                                  ; ======================================================================================
                                                  ;   Memory locations 0-255 ($0-$FF) have a special significance in 6502
                                                  ;   machine language programming (the 6510 microprocessor in the
                                                  ;   Commodore 64 shares the same instruction set as the 6502). Since
                                                  ;   these addresses can be expressed using just one byte, instructions
                                                  ;   which access data stored in these locations are shorter and execute
                                                  ;   more quickly than do instructions which operate on addresses in
                                                  ;   higher memory, which require two bytes.
                                                  ;   Because of this relatively fast execution time, most 6502
                                                  ;   software makes heavy use of zero-page locations. The 64 is no exception,
                                                  ;   and uses this area for many important system variables and pointers.
                                                  ;   In addition, locations 0 and 1 have special Input/Output functions on the 6510.
                                                  ;   In the case of the 64, this on-chip I/O port is
                                                  ;   used to select the possible combinations of ROM, as we will see below,
                                                  ;   and to control cassette I/O.
                                                  ; ======================================================================================
                                                  
                                                  D6510   = $00
                                                  ; ======================================================================================
                                                  ;
                                                  ; D6510         $00
                                                  ;
                                                  ; 6510 On-Chip I/O DATA Direction Register
                                                  ; Bit 0: Direction of Bit 0 I/O on port at next address. Default =1 (output)
                                                  ; Bit 1: Direction of Bit 1 I/O on port at next address. Default =1 (output)
                                                  ; Bit 2: Direction of Bit 2 I/O on port at next address. Default=l (output)
                                                  ; Bit 3: Direction of Bit 3 I/O on port at next address. Default=l (output)
                                                  ; Bit 4: Direction of Bit 4 I/O on port at next address. Default=0 (input)
                                                  ; Bit 5: Direction of Bit 5 I/O on port at next address. Default=l (output)
                                                  ; Bit 6: Direction of Bit 6 I/O on port at next address. Not used.
                                                  ; Bit 7: Direction of Bit 7 I/O on port at next address. Not used.
                                                  ;
                                                  ; This location is the first of a number of hardware registers.
                                                  ; Although they can be written to and/or read like RAM,
                                                  ; they are connected to hardware devices, and their contents affect the
                                                  ; operation of the devices.
                                                  ; Each bit of this Data Direction Register determines whether the
                                                  ; contents of the corresponding bit on the Internal I/O Port (see location 1)
                                                  ; can be written to by peripheral devices. If the bit is set to 0, it
                                                  ; indicates the direction of data flow as Input, which means that the
                                                  ; corresponding bit of the I/O Port will be affected by peripheral devices.
                                                  ; If the bit is set to 1, it indicates Output. On the 64, only Bits 0-5
                                                  ; are significant. On power-up, this register is set to 239 ($EF),
                                                  ; which indicates that all bits, except for Bit 4 (which senses the cassette switch),
                                                  ; are set up for Output.
                                                  ; ======================================================================================
                                                  
                                                  R6510   = $01
                                                  ; ======================================================================================
                                                  ;
                                                  ; R6510         $01
                                                  ;
                                                  ; Bit 0: LORAM signal. Selects ROM or RAM at 40960 ($A000). 1 = BASIC, 0=RAM
                                                  ; Bit 1: HIRAM signal. Selects ROM or RAM at 57344 ($E000). l=Kernal, 0=RAM
                                                  ; Bit 2: CHAREN signal. Selects character ROM or I/O devices. 1 =I/O, 0=ROM
                                                  ; Bit 3: Cassette Data Output line.
                                                  ; Bit 4: Cassette Switch Sense. Reads 0 if a button is pressed, 1 if not.
                                                  ; Bit 5: Cassette Motor Control. A 1 turns the motor on, a 0 turns it off.
                                                  ; Bits 6-7: Not connected—no function presently defined.
                                                  ;
                                                  ; The chief function of this register is to determine which blocks of
                                                  ; RAM and ROM the 6510 microprocessor will address. The Commodore 64
                                                  ; comes with 64K RAM, even though it normally does not use
                                                  ; all of that RAM at once. In addition, it has an 8K BASIC Interpreter
                                                  ; ROM, an 8K Operating System Kernal ROM, a 4K Character Generator
                                                  ; ROM, a Sound Interface Device (SID), a 6566 Video Interface
                                                  ; Controller (VIC-II), and two 6526 Complex Interface Adapter chips.
                                                  ; To address all of these at once would require 88K, 24K past the
                                                  ; addressing limit of the 6510 microprocessor. In order to allocate
                                                  ; address space, the I/O Port is used to affect the addressing lines, and
                                                  ; thus determine which segments of RAM and ROM will be addressed
                                                  ; at any one time.
                                                  ; ======================================================================================
                                                  
                                                  UNUSED1 = $02
                                                  ; ======================================================================================
                                                  ;
                                                  ; UNUSED        $02
                                                  ;
                                                  ; unused
                                                  ; ======================================================================================
                                                  
                                                  ADRAY1  = $03
                                                  ; ======================================================================================
                                                  ;
                                                  ; ADRAY1        $03 - $04
                                                  ;
                                                  ; This vector points to the address of the BASIC routine which converts
                                                  ; a floating point number to an integer. In the current Kernal
                                                  ; version, the address that it points to is 45482 ($B1AA). Disassembly
                                                  ; of the ROMs indicates that BASIC does not use this vector. However,
                                                  ; it may be of real assistance to the programmer who wishes to
                                                  ; use data that is stored in floating point format. The parameter that is
                                                  ; passed by the USR command is available only in that format, for example.
                                                  ; Since it is extremely difficult to decipher and use a floating point
                                                  ; number, the simplest way to deal with such data is to use the conversion
                                                  ; routines that are built into BASIC to change it into a two byte
                                                  ; signed integer. This could be accomplished by jumping directly
                                                  ; into the BASIC ROM, if you know the location of the routine. It is
                                                  ; preferable to use this vector because it will always point to the location
                                                  ; of the routine. Therefore, if the address changes in future versions
                                                  ; of the 64 or future Commodore computers, you won't have to
                                                  ; modify your program to make it work with them.
                                                  ; See the entry for the USR vector at 785 ($311) for an explanation
                                                  ; of how to use this routine in connection with the USR command.
                                                  ; ======================================================================================
                                                  
                                                  ADRAY2  = $05
                                                  ; ======================================================================================
                                                  ;
                                                  ; ADRAY2        $05 - $06
                                                  ;
                                                  ; Vector: Routine to Convert a Number from Integer to Floating Point
                                                  ; This vector points to the address of the BASIC routine which converts
                                                  ; an integer to a floating point number. This routine is currently
                                                  ; located at 45969 ($B391). BASIC does not appear to reference this
                                                  ; location. It is available for use by the programmer who needs to
                                                  ; make such a conversion for a machine language program that interacts
                                                  ; with BASIC. For an explanation of how to use this routine in
                                                  ; connection with the USR command, see the entry for the USR vector
                                                  ; at 785 ($311)
                                                  ; ======================================================================================
                                                  
                                                  CHARAC  = $07
                                                  ; ======================================================================================
                                                  ;
                                                  ; CHARAC        $07
                                                  ;
                                                  ; Search Character for Scanning BASIC Text Input
                                                  ; This location and the next are used heavily by the BASIC routines
                                                  ; that scan the text that comes into the buffer at 512 ($200), in order
                                                  ; to detect significant characters such as quotes, comma, the colon
                                                  ; which separates BASIC statements, and end-of-line. The ASCII
                                                  ; values of such special characters are usually stored here.
                                                  ; This location is also used as a work area by other BASIC
                                                  ; routines that do not involve scanning text.
                                                  ; ======================================================================================
                                                  
                                                  ENDCHAR = $08
                                                  ; ======================================================================================
                                                  ;
                                                  ; ENDCHAR       $08
                                                  ;
                                                  ; Search Character for Statement Terminator or Quote
                                                  ; Like location 7, this location is used as a work byte during the
                                                  ; tokenization of a BASIC statement. Most of the time, its value is 0 or 34.
                                                  ; ======================================================================================
                                                  
                                                  TRMPOS  = $09
                                                  ; ======================================================================================
                                                  ;
                                                  ; TRMPOS        $09
                                                  ;
                                                  ; Column Position of the Cursor before the Last TAB or SPC
                                                  ; TRMPOS is used by TAB and SPC. The cursor column position prior
                                                  ; to the TAB or SPC is moved here from 211 ($D3), and is used to calculate
                                                  ; where the cursor ends up after one of these functions is invoked.
                                                  ; Note that the value contained here shows the position of the
                                                  ; cursor on a logical line. Since one logical line can be up to two physical
                                                  ; lines long, the value stored here can range from 0 to 79.
                                                  ; ======================================================================================
                                                  
                                                  VERCK   = $0A
                                                  ; ======================================================================================
                                                  ;
                                                  ; VERCK         $0A
                                                  ;
                                                  ; Flag: LOAD or VERIFY
                                                  ; BASIC uses one Kernal routine to perform either the LOAD or VERIFY
                                                  ; function, depending on whether the Accumulator (.A) is set to 0
                                                  ; or 1 upon entry to the routine. BASIC sets the value of VERCK to 0
                                                  ; for a LOAD, or 1 for a VERIFY. Its contents are passed to the Kernal
                                                  ; LOAD routine, which in turn stores it in location 147 ($93).
                                                  ; ======================================================================================
                                                  
                                                  COUNT   = $0B
                                                  ; ======================================================================================
                                                  ;
                                                  ; COUNT         $0B
                                                  ;
                                                  ; Index into the Text Input Buffer/Number of Array Subscripts
                                                  ; The routines that convert the text in the input buffer at 512 ($20b)
                                                  ; into lines of executable program tokens, and the routines that link
                                                  ; these program lines together, use this location as an index into the
                                                  ; input buffer area. When the job of converting text to tokens is finished,
                                                  ; the value in this location is equal to the length of the
                                                  ; tokenized line.
                                                  ; The routines which build an array or locate an element in an array
                                                  ; use this location to calculate the number of DIMensions called
                                                  ; for and the amount of storage required for a newly created array, or
                                                  ; the number of subscripts specified when referencing an array element.
                                                  ; ======================================================================================
                                                  
                                                  DIMFLG  = $0C
                                                  ; ======================================================================================
                                                  ;
                                                  ; DIMFLG        $0C
                                                  ;
                                                  ; Flags for the Routines That Locate or Build an Array
                                                  ; This location is used as a flag by the routines that build an array or
                                                  ; reference an existing array. It is used to determine whether a variable
                                                  ; is an array, whether the array has already been DIMensioned, and
                                                  ; whether a new array should assume the default dimensions.
                                                  ; ======================================================================================
                                                  
                                                  VALTYP  = $0D
                                                  ; ======================================================================================
                                                  ;
                                                  ; VALTYP        $0D
                                                  ;
                                                  ; Flag: Type of Data (String or Numeric)
                                                  ; This flag is used internally to indicate whether data being operated
                                                  ; upon is string or numeric. A value of 255 ($FF) in this location indicates
                                                  ; string data, while a 0 indicates numeric data. This determination
                                                  ; is made every time a variable is located or created.
                                                  ; ======================================================================================
                                                  
                                                  INTFLG  = $0E
                                                  ; ======================================================================================
                                                  ;
                                                  ; INTFLG        $0E
                                                  ;
                                                  ; Flag: Type of Numeric Data (Integer or Floating Point)
                                                  ; If data which BASIC is using is determined to be numeric, it is further
                                                  ; classified here as either a floating point number or as an integer.
                                                  ; A 128 ($80) in this location identifies the number as an integer, and
                                                  ; indicates a floating point number.
                                                  ; ======================================================================================
                                                  
                                                  GARBFLG = $0F
                                                  ; ======================================================================================
                                                  ;
                                                  ; GARBFLG       $0F
                                                  ;
                                                  ; Flag for LIST, Garbage Collection, and Program Tokenization
                                                  ; The LIST routine uses this byte as a flag to let it know when it has
                                                  ; come to a character string in quotes. It will then print the string,
                                                  ; rather than search it for BASIC keyword tokens.
                                                  ; The garbage collection routine uses this location as a flag to indicate
                                                  ; that garbage collection has already been tried before adding a
                                                  ; new string. If there is still not enough memory, an OUT OF MEMORY
                                                  ; message will result.
                                                  ; This location is also used as a work byte for the process of converting
                                                  ; a line of text in the BASIC input buffer (512, $200) into a
                                                  ; linked program line of BASIC keyword tokens.
                                                  ; ======================================================================================
                                                  
                                                  SUBFLG  = $10
                                                  ; ======================================================================================
                                                  ;
                                                  ; SUBFLG        $10
                                                  ;
                                                  ; Flag: Subscript Reference to an Array or User-Defined Function
                                                  ; Call (FN)
                                                  ; This flag is used by the PTRGET routine which finds or creates
                                                  ; a variable, at the time it checks whether the name of a variable is
                                                  ; valid. If an opening parenthesis is found, this flag is set to indicate
                                                  ; that the variable in question is either an array variable or a userdefined function.
                                                  ; You should note that it is perfectly legal for a user-defined function (FN)
                                                  ; to have the same name as a floating point variable. Moreover, it
                                                  ; is also legal to redefine a function. Using a FN name in an
                                                  ; already defined function results in the new definition of the function.
                                                  ; ======================================================================================
                                                  
                                                  INPFLG  = $11
                                                  ; ======================================================================================
                                                  ;
                                                  ; INPFLG        $11
                                                  ;
                                                  ; Flag: Is Data Input to GET, READ or INPUT?
                                                  ; Since the keywords GET, INPUT, and READ perform similar functions,
                                                  ; BASIC executes some of the same instructions for all three.
                                                  ; There are also many areas of difference, however, and this flag indicates
                                                  ; which of the three keywords is currently being executed, so
                                                  ; that BASIC will know whether or not to execute the instructions
                                                  ; which relate to the areas in which the commands differ (152
                                                  ; ($98) = READ, 64 ($40)= GET, 0=INPUT).
                                                  ; As a result, INPUT will show the ? prompt, will echo characters
                                                  ; back to the screen, and will wait for a whole line of text ended by a
                                                  ; carriage return. GET gives no prompt and accepts one character
                                                  ; without waiting. The colon character and the comma are valid data
                                                  ; for GET, but are treated as delimiters between data by INPUT and
                                                  ; READ. As each command has its own error messages, this flag is used
                                                  ; to determine the appropriate message to issue in case of an error.
                                                  ; ======================================================================================
                                                  
                                                  TANSGN  = $12
                                                  ; ======================================================================================
                                                  ;
                                                  ; TANSGN        $12
                                                  ;
                                                  ; Flag: Sign of the Result of the TAN or SIN Function
                                                  ; This location is used to determine whether the sign of the value re
                                                  ; turned by the functions SIN or TAN is positive or negative.
                                                  ; Additionally, the string and numeric comparison routines use
                                                  ; this location to indicate the outcome of the comparison. For a com
                                                  ; parison of variable A to variable B, the value here will be 1 if A is
                                                  ; greater than B, 2 if A equals B, and 4 if A is less than B. If more than
                                                  ; one comparison operator was used to compare the two variables
                                                  ; (e.g., >= or <= ), the value here will be a combination of the
                                                  ; above values.
                                                  ; ======================================================================================
                                                  
                                                  CHANNL  = $13
                                                  ; ======================================================================================
                                                  ;
                                                  ; CHANNL        $13
                                                  ;
                                                  ; Current I/O Channel (CMD Logical File) Number
                                                  ; Whenever BASIC inputs or outputs data, it looks here to determine
                                                  ; which I/O device is currently active for the purpose of prompting or
                                                  ; output control. It uses location 184, $B8 for purposes of deciding
                                                  ; what device actually to input from or output to.
                                                  ; When the default input device (number 0, the keyboard) or output
                                                  ; device (number 3, the display screen) is used, the value here will
                                                  ; be a zero, and the format of prompting and output will be the standard
                                                  ; screen output format.
                                                  ; When another device is used, the logical file number (CMD
                                                  ; channel number) will be placed here. This lets the system know that
                                                  ; it may have to make some subtle changes in the way it performs the
                                                  ; I/O operation. For example, if TAB is used with the PRINT command,
                                                  ; cursor right characters are used if the device PRINTed to is
                                                  ; the screen. Otherwise, spaces are output when the number here is
                                                  ; other than zero (the assumption being that you can't tab a printer
                                                  ; like you can the screen).
                                                  ; Likewise, the ? prompt for INPUT is suppressed if the file number
                                                  ; here is nonzero, as is the EXTRA IGNORED message, and input
                                                  ; of a carriage return by itself is ignored, rather than being treated as a
                                                  ; null string (""). Therefore, by OPENing the screen as a device, and
                                                  ; issuing the CMD statement, you can force the suppression of the ?,
                                                  ; prompt, and the other effects above.
                                                  ; CMD places the new output file number here, and calls the
                                                  ; Kernal to open the device for output, leaving it LISTENing for output
                                                  ; (such as the READY prompt, which is diverted to the new device).
                                                  ; Many routines reset this location and UNLISTEN the device, defeating
                                                  ; the CMD and once again sending output to the screen. If an
                                                  ; error message has to be displayed, for example, this location will be
                                                  ; reset and the message will be displayed on the screen. GET, GET#,
                                                  ; INPUT, INPUT#, and PRINT# all will reset this location after the
                                                  ; I/O is completed, effectively redirecting output back to the screen.
                                                  ; PRINT and LIST are the only I/O operations that will not undo the CMD.
                                                  ; This location can also be used to fool BASIC into thinking that
                                                  ; data it is reading from the tape is actually being entered into the
                                                  ; keyboard in immediate mode.
                                                  ; For a look at a technique that uses a different approach to accomplish
                                                  ; the same thing for disk or tape users, see location 512
                                                  ; ($200), the keyboard buffer.
                                                  ; ======================================================================================
                                                  
                                                  LINNUM  = $14
                                                  ; ======================================================================================
                                                  ;
                                                  ; LINNUM        $14
                                                  ;
                                                  ; Integer Line Number Value
                                                  ; The target line number for GOTO, LIST, ON, and GOSUB is stored
                                                  ; here in low-byte, high-byte integer format, as is the number of a
                                                  ; BASIC line that is to be added or replaced.
                                                  ; LIST saves the highest line number to list (or 65535—$FFFF if
                                                  ; program is to be listed to the end) at this location. < 1
                                                  ; GOTO tests the target line number to see if it is greater than the
                                                  ; line number currently being executed. If it is greater, GOTO starts its
                                                  ; search for the target line at the current line number. If it is not J
                                                  ; greater, GOTO must search for the target line from the first line of
                                                  ; the program. It is interesting to note that the test is of the most
                                                  ; significant byte only. Therefore, INT (TARGETLINE/256) must be
                                                  ; greater than INT(CURRENT LINE/256) in order for the search to
                                                  ; start with the current line, instead of at the beginning of the
                                                  ; program. PEEK, POKE, WAIT, and SYS use this location as a pointer to
                                                  ; the address which is the subject of the command.
                                                  ; ======================================================================================
                                                  
                                                  TEMPPT  = $16
                                                  ; ======================================================================================
                                                  ;
                                                  ; TEMPPT        $16
                                                  ;
                                                  ; Pointer to the Next Available Space in the Temporary String Stack
                                                  ; This location points to the next available slot in the temporary string
                                                  ; descriptor stack located at 25-33 ($19-$21). Since that stack has room
                                                  ; for three descriptors of three bytes each, this location will point to 25
                                                  ; ($19) if the stack is empty, to 28 ($1C) if there is one entry, to 31
                                                  ; ($1F) if there are two entries, and to 34 ($22) if the stack is full.
                                                  ; If BASIC needs to add an entry to the temporary string descriptor
                                                  ; stack, and this location holds a 34, indicating that the stack is
                                                  ; full, the FORMULA TOO COMPLEX error message is issued. Otherwise,
                                                  ; the entry is added, and three is added to this pointer.
                                                  ; ======================================================================================
                                                  
                                                  LASTPT  = $17
                                                  ; ======================================================================================
                                                  ;
                                                  ; LASTPT        $17
                                                  ;
                                                  ; Pointer to the Address of the Last String in the Temporary String Stack
                                                  ; This pointer indicates the last slot used in the temporary string descriptor
                                                  ; stack. Therefore, the value stored at 23 ($17) should be 3
                                                  ; less than that stored at 22 ($16), while 24 ($18) will contain a 0.
                                                  ; ======================================================================================
                                                  
                                                  TEMPST  = $19
                                                  ; ======================================================================================
                                                  ;
                                                  ; TEMPST        $19
                                                  ;
                                                  ; Descriptor Stack for Temporary Strings
                                                  ; The temporary string descriptor stack contains information about
                                                  ; temporary strings which have not yet been assigned to a string variable.
                                                  ; An example of such a temporary string is the literal string
                                                  ; "HELLO" in the statement PRINT "HELLO".
                                                  ; Each three-byte descriptor in this stack contains the length of
                                                  ; the string, and its starting and ending locations, expressed as displacements
                                                  ; within the BASIC storage area.
                                                  ; ======================================================================================
                                                  
                                                  INDEX   = $22
                                                  ; ======================================================================================
                                                  ; Miscellaneous Temporary Pointers and Save Area
                                                  ; This area is used by many BASIC routines to hold temporary pointers
                                                  ; and calculation results.
                                                  ; ======================================================================================
                                                  
                                                  RESHO   = $26                           ;   floating point work area 26-2a
                                                  TXTTAB  = $2B                           ;   basic start 2b-2c
                                                  VARTAB  = $2D                           ;   pointer to start of the basic variable table 2d-2e
                                                  ARYTAB  = $2F                           ;   pointer to start of basic array storage 2f-30
                                                  STREND  = $31                           ;   pointer to endof basic array storage area + 1 32-32
                                                  FRETOP  = $33                           ;   pointer to bottom of the string text storage area 33-34
                                                  FRESPC  = $35                           ;   temporary pointer for strings 35-36
                                                  MEMSIZ  = $37                           ;   pointer to highest address used by basic 37-38
                                                  CURLIN  = $39                           ;   current line number (FF in $3a signifies immediate mode) $39-3a
                                                  OLDLIN  = $3B                           ;   previous line number (used by cont) 3b-3c
                                                  OLDTXT  = $3D                           ;   pointer to current basic statement 3d-3e
                                                  DATLIN  = $3F                           ;   current data line number 3f-40
                                                  DATPTR  = $41                           ;   pointer to current data item 42-42
                                                  INPPTR  = $43                           ;   pointer to source of get read or input info 43-44
                                                  VARNAM  = $45                           ;   pointer to current basic variable name 46-46
                                                  VARPNT  = $47                           ;   pointer to current basic variable value 47-48
                                                  FORPNT  = $49                           ;   temporary pointer to index used by for 49-4a
                                                  OPPTR   = $4B                           ;   math operator table displacent 4b-4c
                                                  OPMASK  = $4D                           ;   math comparison operation mask
                                                  DEFPNT  = $4E                           ;   pointer to current FN description 4e-4f
                                                  DSCPNT  = $50                           ;   temporary pointer to current string description 50-52
                                                  FOUR6   = $53                           ;   constant for garbage collection
                                                  JMPER   = $54                           ;   jump to function instruction 84-86
                                                  UNUSED2 = $57                           ;   numeric work area 57-60
                                                  FAC1    = $61                           ;   fac1 61-66
                                                  FACEXP  = $61                           ;   fac1 exponent
                                                  FACHO   = $62                           ;   fac1 mantissa 62-65
                                                  FACSSGN = $66                           ;   fac1 sign
                                                  SGNFLG  = $67                           ;   number of terms in series evaluation
                                                  BITS    = $68                           ;   overflow digit
                                                  FAC2    = $69                           ;   fac2 69-6e
                                                  ARGEXP  = $69                           ;   fac2 exponent
                                                  ARGHO   = $6A                           ;   fac2 mantissa 6a-6d
                                                  ARGSGN  = $6E                           ;   fac2 sign
                                                  FACOV   = $70                           ;   low order mantissa fac1
                                                  FBUFPTR = $71                           ;   series evaluation pointer 71-72
                                                  CHRGET  = $73                           ;   subroutine get next basic text char 73-8a
                                                  TXTPTR  = $7A                           ;
                                                  POINTB  = $7C                           ;
                                                  RNDX    = $8B                           ;   random seed value 8b-8f
                                                  STATUS  = $90                           ;   kernal io status
                                                  STKEY   = $91                           ;   was stop key pressed
                                                  SVXT    = $92                           ;   timing constant for tape
                                                  VERCK2  = $93                           ;   flag for load or verify 0 = load 1 = verify
                                                  C3PO    = $94                           ;   serial bus output char was buffered
                                                  BSOUR   = $95                           ;   bufferd char for serial bus
                                                  SYNO    = $96                           ;   cassette block syncronization number
                                                  XSAV    = $97                           ;   temporary x register save
                                                  LDTND   = $98                           ;   number of open io files
                                                  DFLTN   = $99                           ;   default input device (0=keyboard)
                                                  DFLTO   = $9A                           ;   default output device (3 = screen)
                                                  PRTY    = $9B                           ;   tape parity
                                                  DPSW    = $9C                           ;   tape byte received
                                                  MSGFLG  = $9D                           ;   kernal message control
                                                  PTR1    = $9E                           ;   tape pass1 error log
                                                  PTR2    = $9F                           ;   tape pass2 error log
                                                  TIME    = $A0                           ;   jiffy clock a0-a2
                                                  TMPDATA = $A3                           ;   temp data area a3-a4
                                                  CNTDN   = $A5                           ;   cassette syncronzation countdown
                                                  BUFPNT  = $A6                           ;   count of charactors in tape io buffer
                                                  INBIT   = $A7                           ;   cassette temp storage
                                                  BITCI   = $A8                           ;   rs232   - cassette temp storage
                                                  RINONE  = $A9                           ;   rs232 check for start bit
                                                  RIDATA  = $AA                           ;   rs232 input byte
                                                  RIPRTY  = $AB                           ;   rs232 input parity
                                                  SAL     = $AC                           ;   start address of screen load/scrolling ac-ad
                                                  EAL     = $AE                           ;   end of program ae-af
                                                  CMP0    = $B0                           ;   tape timing b0-b1
                                                  TAPE1   = $B2                           ;   start of tape buffer b2-b3
                                                  BITTS   = $B4                           ;   rs232 bit counter
                                                  NXTBIT  = $B5                           ;   rs232 next bit to send
                                                  RODATA  = $B6                           ;   rs232 output byte buffer
                                                  FNLEN   = $B7                           ;   length of current filename
                                                  LA      = $B8                           ;   current logical file number
                                                  SA      = $B9                           ;   current secondary address
                                                  FA      = $BA                           ;   current device number
                                                  FNADR   = $BB                           ;   pointer current file name bb-bc
                                                  ROPRTY  = $BD                           ;   rs232 output parity
                                                  FSBLK   = $BE                           ;   cassette read write block count
                                                  MYCH    = $BF                           ;   tape input buffer
                                                  CAS1    = $C0                           ;   tape motor interlock
                                                  STAL    = $C1                           ;   io start address c1-c2
                                                  MEMUSS  = $C3                           ;   tape load temp address c3-c4
                                                  LSTX    = $C5                           ;   matrix coordinate of last key pressed
                                                  NDX     = $C6                           ;   number of characters in keyboard buffer
                                                  RVS     = $C7                           ;   print characters in reverse
                                                  INDX    = $C8                           ;   end of logical line input
                                                  LXSP    = $C9                           ;   cursor at start of input c9-ca
                                                  SFDX    = $CB                           ;   matrix coordinate of current key pressed
                                                  BLNSW   = $CC                           ;   cursor blink enable
                                                  BLNCT   = $CD                           ;   countdown to blink cursor
                                                  GDBLN   = $CE                           ;   character under cursor
                                                  BLNON   = $CF                           ;   was the last charactor blink on or off
                                                  CRSW    = $D0                           ;   input from keyboard or screen
                                                  PNT     = $D1                           ;   pointer address of current screen line d1-d2
                                                  PNTR    = $D3                           ;   cursor column on on current line
                                                  QTSW    = $D4                           ;   editor in quote mode?
                                                  LNMX    = $D5                           ;   msx length of physical screen line
                                                  TBLX    = $D6                           ;   current cursor physical line number
                                                  UNUSED3 = $D7                           ;   temp stprage area for ascii value of last char
                                                  INSRT   = $D8                           ;   insert mode
                                                  LDTB1   = $D9                           ;   screen line link table d9-f2
                                                  USER    = $F3                           ;   pointer address of current screen color ram f3-f4
                                                  KEYTAB  = $F5                           ;   keyboard decode table f5-f6
                                                  RIBUF   = $F7                           ;   pointer rs232 input buffer f7-f8
                                                  ROBUF   = $F9                           ;   pointer rs232 ouput buffer f9-fa
                                                  FREKZP  = $FB                           ;   free 0 page fb-fe
                                                  BASZPT  = $FF                           ;   temporary floatingpoint to ascii

Processing kernal.asm

                                                  TEXT    = $0286
                                                  IERROR  = $0300
                                                  IMAIN   = $0302
                                                  IGONE   = $0308
                                                  
                                                  CIAICR  = $DC0D
                                                  CIACRA  = $DC0E
                                                  CI2ICR  = $DD0D
                                                  CI2CRA  = $DD0E
                                                  
                                                  LOAD    = $FFD5
                                                  RESTOR  = $FF8A
                                                  SETLFS  = $FFBA
                                                  SETNAM  = $FFBD
                                                  
                                                  POLY1   = $E043
                                                  POLY2   = $E059
                                                  RMULC   = $E08D
                                                  RADDC   = $E092
                                                  RND     = $E097
                                                  SYS     = $E12A
                                                  SAVE    = $E156
                                                  VERIFY  = $E165
                                                  LOAD_   = $E168
                                                  OPEN    = $E1BE
                                                  CLOSE   = $E1C7
                                                  COS     = $E264
                                                  SIN     = $E26B
                                                  TAN     = $E2B4
                                                  PI2     = $E2E0
                                                  TWOPI   = $E2E5
                                                  FR4     = $E2EA
                                                  SINCON  = $E2EF
                                                  ATN     = $E30E
                                                  ATNCON  = $E33E
                                                  WARM    = $E37B
                                                  COLD    = $E394
                                                  INITAT  = $E3A2
                                                  INIT    = $E3BF
                                                  WORDS   = $E460
                                                  IOBASE  = $E500
                                                  SCREEN  = $E505
                                                  PLOT    = $E50A
                                                  LP2     = $E5B4
                                                  SCNKEY  = $EA87
                                                  TALK    = $ED09
                                                  LISTEN  = $ED0C
                                                  SECOND  = $EDB9
                                                  TKSA    = $EDC7
                                                  CIOUT   = $EDDD
                                                  UNTLK   = $EDFE
                                                  ACPTR   = $EE13
                                                  GETIN   = $F13E
                                                  CHRIN   = $F157
                                                  _CHROUT = $F1CA                         ;   pointed to by CHROUT $FFD2
                                                  
                                                  CHROUT  = $FFD2
                                                  
                                                  BORDER  = $D020
                                                  SCREENC = $D021

Processing basic.asm

                                                  
                                                  STMDSP  = $A00C
                                                  FUNDSPTABLE = $A052
                                                  OPTAB   = $A080
                                                  RESLST  = $A09E
                                                  ERRTAB  = $A19E
                                                  FNDFOR  = $A38A
                                                  BLTU    = $A3B8
                                                  GETSTK  = $A3FB
                                                  REASON  = $A408
                                                  OMERR   = $A435
                                                  ERROR   = $A437
                                                  READY   = $A474
                                                  MAIN    = $A480
                                                  MAIN1   = $A49C
                                                  LINKPRG = $A533
                                                  INLIN   = $A560
                                                  CRUNCH  = $A579
                                                  FNDLIN  = $A613
                                                  SCRTCH  = $A642
                                                  CLEAR   = $A65E
                                                  RUNC    = $A68E
                                                  LIST    = $A69C
                                                  QPLOP   = $A717
                                                  FOR     = $A742
                                                  NEWSTT  = $A7AE
                                                  GONE    = $A7E4
                                                  RESTOR_ = $A81D
                                                  STOP    = $A82F
                                                  END     = $A831
                                                  CONT    = $A857
                                                  RUN     = $A871
                                                  GOSUB   = $A883
                                                  GOTO    = $A8A0
                                                  RETURN  = $A8D2
                                                  DATA    = $A8F8
                                                  DATAN   = $A906
                                                  IF      = $A928
                                                  REM     = $A93B
                                                  ONGOTO  = $A94B
                                                  LINGET  = $A96B
                                                  LET     = $A9A5
                                                  PRINTN  = $AA80
                                                  CMD     = $AA86
                                                  PRINT   = $AAA0
                                                  STROUT  = $AB1E
                                                  DOAGAIN = $ABA5
                                                  GET     = $AB7B
                                                  INPUTN  = $ABA5
                                                  INPUT   = $ABBF
                                                  READ    = $AC06
                                                  EXIFNT  = $ACFC
                                                  NEXT    = $AD1D
                                                  FRMNUM  = $AD8A
                                                  FRMEVL  = $AD9E
                                                  EVAL    = $AE83
                                                  PIVAL   = $AEA8
                                                  PARCHK  = $AEF1
                                                  CHKCLS  = $AEF7
                                                  CHKOPN  = $AEFA
                                                  CHKCOM  = $AEFF
                                                  SNERR   = $AF08
                                                  ISVAR   = $AF2B
                                                  ISFUN   = $AFA7
                                                  OROP    = $AFE6
                                                  ANDOP   = $AFE9
                                                  DORE1   = $B016
                                                  DIM     = $B081
                                                  PTRGET  = $B08B
                                                  NOTFNS  = $B11D
                                                  FINPTR  = $B185
                                                  ARYGET  = $B194
                                                  N32768  = $B1A5
                                                  INTIDX  = $B1B2
                                                  AYINT   = $B1BF
                                                  ISARY   = $B1D1
                                                  BSERR   = $B245
                                                  FCERR   = $B248
                                                  UMULT   = $B34C
                                                  FRE     = $B37D
                                                  GIVAYF  = $B391
                                                  POS     = $B39E
                                                  ERRDIR  = $B3A6
                                                  DEF     = $B3B3
                                                  GETFNM  = $B3E1
                                                  FBDOER  = $B3F4
                                                  STRD    = $B465
                                                  STRLIT  = $B487
                                                  GETSPA  = $B4F4
                                                  GARBAG  = $B536
                                                  CAT     = $B63D
                                                  MOVINS  = $B67A
                                                  FRESTR  = $B6A3
                                                  FRETMS  = $B6DB
                                                  CHRD    = $B6EC
                                                  LEFTD   = $B700
                                                  RIGHTD  = $B72C
                                                  MIDD    = $B737
                                                  PREAM   = $B761
                                                  LEN     = $B77C
                                                  ASC     = $B78B
                                                  GETBYTC = $B79B
                                                  VAL     = $B7AD
                                                  GETNUM  = $B7EB
                                                  GETADR  = $B7F7
                                                  PEEK    = $B80D
                                                  POKE    = $B824
                                                  FUWAIT  = $B82D
                                                  FADDH   = $B849
                                                  FSUB    = $B850
                                                  FSUBT   = $B853
                                                  FADD    = $B867
                                                  FADDT   = $B86A
                                                  FADD4   = $B8A7
                                                  NORMAL  = $B8FE
                                                  NEGFAC  = $B947
                                                  OVERR   = $B97E
                                                  MULSHF  = $B983
                                                  FONE    = $B9BC
                                                  LOGCN2  = $B9C1
                                                  LOG     = $B9EA
                                                  FMULT   = $BA28
                                                  FMULT1  = $BA33
                                                  MLTPLY  = $BA59
                                                  CONUPK  = $BA8C
                                                  MULDIV  = $BAB7
                                                  MLDVEX  = $BAD4
                                                  MUL10   = $BAE2
                                                  TENC    = $BA79
                                                  DIV10   = $BAFE
                                                  FDIV    = $BB0F
                                                  FDIVT   = $BB12
                                                  MOVFM   = $BBA2
                                                  MOV2F   = $BBC7
                                                  MOVFA   = $BBFC
                                                  MOVAF   = $BC0C
                                                  MOVEF   = $BC0F
                                                  ROUND   = $BC1B
                                                  SIGN    = $BC2B
                                                  SGN     = $BC39
                                                  ABS     = $BC58
                                                  FCOMP   = $BC5B
                                                  QINT    = $BC9B
                                                  INT     = $BCCC
                                                  FIN     = $BCF3
                                                  FINLOG  = $BD7E
                                                  N0999   = $BDC0
                                                  LINPRT  = $BDCD
                                                  FOUT    = $BDDD
                                                  FHALF   = $BF11
                                                  FOUTBL  = $BF1C
                                                  FDCEND  = $BF3A
                                                  SQR     = $BF71
                                                  FPWRT   = $BF7B
                                                  NEGOP   = $BFB4
                                                  EXPCON  = $BFBF
                                                  EXP     = $BFED
                                                  
                                                  
                                                  KEYD    = $0277
                                                  ;
                                                  ;   BASIC TOKENS
                                                  ;
                                                  END_TOK     = $80                       ;   TOKEN FOR END
                                                  FOR_TOK     = $81                       ;   TOKEN FOR FOR
                                                  NEXT_TOK    = $82                       ;   TOKEN FOR NEXT
                                                  DATA_TOK    = $83                       ;   TOKEN FOR DATA
                                                  INPUTN_TOK  = $84                       ;   TOKEN FOR INPUT#
                                                  INPUT_TOK   = $85                       ;   TOKEN FOR INPUT
                                                  DIM_TOK     = $86                       ;   TOKEN FOR DIM
                                                  READ_TOK    = $87                       ;   TOKEN FOR READ
                                                  LET_TOK     = $88                       ;   TOKEN FOR LET
                                                  GOTO_TOK    = $89                       ;   TOKEN FOR GOTO
                                                  RUN_TOK     = $8A                       ;   TOKEN FOR RUN
                                                  IF_TOK      = $8B                       ;   TOKEN FOR IF
                                                  RESTORE_TOK = $8C                       ;   TOKEN FOR RESTORE
                                                  GOSUB_TOK   = $8D                       ;   TOKEN FOR GOSUB
                                                  RETURN_TOK  = $8E                       ;   TOKEN FOR RETURN
                                                  REM_TOK     = $8F                       ;   TOKEN FOR REM
                                                  STOP_TOK    = $90                       ;   TOKEN FOR STOP
                                                  ON_TOK      = $91                       ;   TOKEN FOR ON
                                                  WAIT_TOK    = $92                       ;   TOKEN FOR WAIT
                                                  LOAD_TOK    = $93                       ;   TOKEN FOR LOAD
                                                  SAVE_TOK    = $94                       ;   TOKEN FOR SAVE
                                                  VERIFY_TOK  = $95                       ;   TOKEN FOR VERIFY
                                                  DEF_TOK     = $96                       ;   TOKEN FOR DEF
                                                  PRINTN_TOK  = $98                       ;   TOKEN FOR PRINTN
                                                  PRINT_TOK   = $99                       ;   TOKEN FOR PRINT
                                                  CONT_TOK    = $9A                       ;   TOKEN FOR CONT
                                                  LIST_TOK    = $9B                       ;   TOKEN FOR LIST
                                                  CLR_TOK     = $9C                       ;   TOKEN FOR CLR
                                                  CMD_TOK     = $9D                       ;   TOKEN FOR CMD
                                                  SYS_TOK     = $9E                       ;   TOKEN FOR SYS
                                                  OPEN_TOK    = $9F                       ;   TOKEN FOR OPEN
                                                  CLOSE_TOK   = $A0                       ;   TOKEN FOR CLOSE
                                                  GET_TOK     = $A1                       ;   TOKEN FOR GET
                                                  NEW_TOK     = $A2                       ;   TOKEN FOR NEW
                                                  TAB_TOK     = $A3                       ;   TOKEN FOR TAB(
                                                  TO_TOK      = $A4                       ;   TOKEN FOR TO
                                                  FN_TOK      = $A5                       ;   TOKEN FOR FN
                                                  SPC_TOK     = $A6                       ;   TOKEN FOR SPC(
                                                  THEN_TOK    = $A7                       ;   TOKEN FOR THEN
                                                  NOT_TOK     = $A8                       ;   TOKEN FOR NOT
                                                  STEP_TOK    = $A9                       ;   TOKEN FOR STEP
                                                  PLUS_TOK    = $AA                       ;   TOKEN FOR PLUS
                                                  MINUS_TOK   = $AB                       ;   TOKEN FOR MINUS
                                                  TIMES_TOK   = $AC                       ;   TOKEN FOR TIMES
                                                  DIVIDE_TOK  = $AD                       ;   TOKEN FOR DIVIDE
                                                  POW_TOK     = $AE                       ;   TOKEN FOR POW
                                                  AND_TOK     = $AF                       ;   TOKEN FOR AND
                                                  OR_TOK      = $B0                       ;   TOKEN FOR OR
                                                  GREATER_TOK = $B1                       ;   TOKEN FOR GREATER
                                                  EQUALS_TOK  = $B2                       ;   TOKEN FOR EQUALS
                                                  LESS_TOK    = $B3                       ;   TOKEN FOR LESS
                                                  SGN_TOK     = $B4                       ;   TOKEN FOR SGN
                                                  INT_TOK     = $B5                       ;   TOKEN FOR INT
                                                  ABS_TOK     = $B6                       ;   TOKEN FOR ABS
                                                  USR_TOK     = $B7                       ;   TOKEN FOR USR
                                                  FRE_TOK     = $B8                       ;   TOKEN FOR FRE
                                                  POS_TOK     = $B9                       ;   TOKEN FOR POS
                                                  SQR_TOK     = $BA                       ;   TOKEN FOR SQR
                                                  RND_TOK     = $BB                       ;   TOKEN FOR RND
                                                  LOG_TOK     = $BC                       ;   TOKEN FOR LOG
                                                  EXP_TOK     = $BD                       ;   TOKEN FOR EXP
                                                  COS_TOK     = $BE                       ;   TOKEN FOR COS
                                                  SIN_TOK     = $BF                       ;   TOKEN FOR SIN
                                                  TAN_TOK     = $C0                       ;   TOKEN FOR TAN
                                                  ATN_TOK     = $C1                       ;   TOKEN FOR ATN
                                                  PEEK_TOK    = $C2                       ;   TOKEN FOR PEEK
                                                  LEN_TOK     = $C3                       ;   TOKEN FOR LEN
                                                  STR_TOK     = $C4                       ;   TOKEN FOR STR
                                                  VAL_TOK     = $C5                       ;   TOKEN FOR VAL
                                                  ASC_TOK     = $C6                       ;   TOKEN FOR ASC
                                                  CHR_TOK     = $C7                       ;   TOKEN FOR CHR
                                                  LEFT_TOK    = $C8                       ;   TOKEN FOR LEFT
                                                  RIGHT_TOK   = $C9                       ;   TOKEN FOR RIGHT
                                                  MID_TOK     = $CA                       ;   TOKEN FOR MID
                                                  GO_TOK      = $CB                       ;   TOKEN FOR GO
                                                  PI_TOK      = $FF                       ;   TOKEN FOR PI
                                                  
                                                  SPACE       = $20                       ;   SPACE
                                                  QUOTE       = $22                       ;   QUOTE
                                                  
                                                  ;
                                                  ;   OFFSETS FROM BASIC LINE POINTER
                                                  ;
                                                  NXOFF   = $00                           ;   OFFSET NEXT ADDRESS
                                                  LNOFF   = $02                           ;   OFFSET LINE NUMBER
                                                  TXTOFF  = $04                           ;   OFFSET TEXT
                                                  
                                                  ;
                                                  ;   ERROR NUMBERS
                                                  ;
                                                  TOOMANYFILES            = 1
                                                  FILEOPEN                = 2
                                                  FILENOTOPEN             = 3
                                                  FILENOTFOUND            = 4
                                                  DEVICENOTPRESENT        = 5
                                                  NOTINPUTFILE            = 6
                                                  NOTOUTPUTFILE           = 7
                                                  MISSINGFILENAME         = 8
                                                  ILLEGALDEVICENUMBER     = 9
                                                  NEXTWITHOUTFOR          = 10
                                                  SYNTAX                  = 11
                                                  RETURNWITHOUTGOSUB      = 12
                                                  OUTOFDATA               = 13
                                                  ILLEGALQUANITY          = 14
                                                  OVERFLOW                = 15
                                                  OUTOFMEMORY             = 16
                                                  UNDEFINEDSTATEMENT      = 17
                                                  BADSUBSCRIPT            = 18
                                                  REDIMARRAY              = 19
                                                  DIVISIONBYZERO          = 20
                                                  ILLEGALDIRECT           = 21
                                                  TYPEMISMATCH            = 22
                                                  STRINGTOOLONG           = 23
                                                  FILEDATA                = 24
                                                  FORMULATOOCOMPLEX       = 25
                                                  CANTCONTINUE            = 26
                                                  UNDEFINEDFUNCTION       = 27
                                                  MSGVERIFY               = 28
                                                  MSGLOAD                 = 29

Processing install.asm

                                                                  *=  $C000
                                                                  TBLLOC  = $A000
                                                  
                                                  .ifdef debug
                                                                  .printall "debug version"
                                                  .endif
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  INSTALL                                 *
                                                  ;*                                          *
                                                  ;********************************************
                                                  INSTALL
                                                  
$C000: $58               cli                                      cli
                                                  
                                                                  ;
                                                                  ;   install wedge
                                                                  ;
$C001: $A0 $01           ldy #$01                                 SAVEZP IGONE,IGONE_SV,2
$C003: $B9 $08 $03       lda $0308,y              
$C006: $99 $34 $C6       sta $C634,y              
$C009: $88               dey                      
$C00A: $10 $F7           bpl $C003                
                                                  
$C00C: $A9 $50           lda #$50                                 lda #<WEDGE
$C00E: $8D $08 $03       sta $0308                                sta IGONE
$C011: $A9 $C0           lda #$C0                                 lda #>WEDGE
$C013: $8D $09 $03       sta $0309                                sta IGONE + 1
                                                  
                                                                  ;
                                                                  ;   set NXTLN
                                                                  ;
$C016: $A5 $2B           lda $2B                                  lda TXTTAB              ;   load start of basic
$C018: $85 $FB           sta $FB                                  sta NXTLN               ;   into next line
$C01A: $85 $31           sta $31                                  sta STREND
$C01C: $A5 $2C           lda $2C                                  lda TXTTAB + 1
$C01E: $85 $FC           sta $FC                                  sta NXTLN + 1
$C020: $85 $32           sta $32                                  sta STREND + 1
                                                  
$C022: $A9 $00           lda #$00                                 lda #0
$C024: $A0 $05           ldy #$05                                 ldy #5
                                                  -
$C026: $91 $FB           sta ($FB),y                              sta (NXTLN),y
$C028: $88               dey                                      dey
$C029: $D0 $FB           bne $C026                                bne -
                                                  
$C02B: $18               clc                                      clc
$C02C: $A9 $02           lda #$02                                 lda #2
$C02E: $65 $31           adc $31                                  adc STREND
$C030: $85 $31           sta $31                                  sta STREND
$C032: $A9 $00           lda #$00                                 lda #0
$C034: $65 $32           adc $32                                  adc STREND + 1
$C036: $85 $32           sta $32                                  sta STREND + 1
                                                  
$C038: $A5 $37           lda $37                                  lda MEMSIZ
$C03A: $85 $33           sta $33                                  sta FRETOP
$C03C: $A5 $38           lda $38                                  lda MEMSIZ + 1
$C03E: $85 $34           sta $34                                  sta FRETOP + 1
                                                  
$C040: $A5 $31           lda $31                                  lda STREND
$C042: $85 $2D           sta $2D                                  sta VARTAB
$C044: $85 $2F           sta $2F                                  sta ARYTAB
$C046: $A5 $32           lda $32                                  lda STREND + 1
$C048: $85 $2E           sta $2E                                  sta VARTAB + 1
$C04A: $85 $30           sta $30                                  sta ARYTAB + 1
$C04C: $78               sei                                      sei
                                                  
$C04D: $4C $7B $E3       jmp $E37B                                jmp WARM
                                                  

Processing wedge.asm

                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  WEDGE                                   *
                                                  ;*                                          *
                                                  ;********************************************
                                                  WEDGE
$C050: $A5 $3A           lda $3A                                  lda CURLIN + 1
$C052: $C9 $FF           cmp #$FF                                 cmp #$FF
$C054: $D0 $4D           bne $C0A3                                bne +++
                                                  
$C056: $A0 $01           ldy #$01                                 ldy #1
                                                  -
$C058: $B9 $EF $C0       lda $C0EF,y                              lda RENUMCMD,y
$C05B: $F0 $07           beq $C064                                beq +
                                                  
$C05D: $D1 $7A           cmp ($7A),y                              cmp (TXTPTR),y
$C05F: $D0 $7D           bne $C0DE                                bne +++++
$C061: $C8               iny                                      iny
$C062: $D0 $F4           bne $C058                                bne -
                                                  +
$C064: $88               dey                                      dey
                                                  -
$C065: $20 $73 $00       jsr $0073                                jsr CHRGET
$C068: $88               dey                                      dey
$C069: $D0 $FA           bne $C065                                bne -
                                                                  ;
                                                                  ;   init line number to 100
                                                                  ;
$C06B: $A9 $64           lda #$64                                 lda #<100
$C06D: $8D $32 $C6       sta $C632                                sta LSTART
$C070: $A9 $00           lda #$00                                 lda #>100
$C072: $8D $33 $C6       sta $C633                                sta LSTART + 1
                                                  
                                                                  ;
                                                                  ;   init line increment
                                                                  ;
$C075: $A9 $0A           lda #$0A                                 lda #<10
$C077: $85 $A3           sta $A3                                  sta INCR
$C079: $A9 $00           lda #$00                                 lda #>10
$C07B: $85 $A4           sta $A4                                  sta INCR + 1
                                                  
$C07D: $A0 $01           ldy #$01                                 ldy #1
$C07F: $B1 $7A           lda ($7A),y                              lda (TXTPTR),y
$C081: $F0 $51           beq $C0D4                                beq +++
                                                  
$C083: $20 $73 $00       jsr $0073                                jsr CHRGET
                                                  +
$C086: $20 $E1 $C0       jsr $C0E1                                jsr GETLN
$C089: $A4 $66           ldy $66                                  ldy LNUMLEN
$C08B: $F0 $51           beq $C0DE                                beq +++
$C08D: $20 $F9 $C0       jsr $C0F9                                jsr VALIDATE
                                                  
$C090: $A5 $FD           lda $FD                                  lda LNUM
$C092: $8D $32 $C6       sta $C632                                sta LSTART
$C095: $A5 $FE           lda $FE                                  lda LNUM + 1
$C097: $8D $33 $C6       sta $C633                                sta LSTART + 1
$C09A: $88               dey                                      dey
$C09B: $F0 $06           beq $C0A3                                beq +
                                                  -
$C09D: $20 $73 $00       jsr $0073                                jsr CHRGET
$C0A0: $88               dey                                      dey
$C0A1: $D0 $FA           bne $C09D                                bne -
                                                  +
$C0A3: $A0 $01           ldy #$01                                 ldy #1
$C0A5: $B1 $7A           lda ($7A),y                              lda (TXTPTR),y
$C0A7: $F0 $2B           beq $C0D4                                beq +
                                                  
$C0A9: $20 $73 $00       jsr $0073                                jsr CHRGET
$C0AC: $C9 $2C           cmp #$2C                                 cmp #','
$C0AE: $D0 $2E           bne $C0DE                                bne ++
                                                  
$C0B0: $A0 $01           ldy #$01                                 ldy #1
$C0B2: $B1 $7A           lda ($7A),y                              lda (TXTPTR),y
$C0B4: $F0 $1E           beq $C0D4                                beq +
                                                  
$C0B6: $20 $73 $00       jsr $0073                                jsr CHRGET
                                                  
$C0B9: $20 $E1 $C0       jsr $C0E1                                jsr GETLN
$C0BC: $A4 $66           ldy $66                                  ldy LNUMLEN
$C0BE: $F0 $1E           beq $C0DE                                beq ++
$C0C0: $20 $F9 $C0       jsr $C0F9                                jsr VALIDATE
                                                  
$C0C3: $A5 $FD           lda $FD                                  lda LNUM
$C0C5: $85 $A3           sta $A3                                  sta INCR
$C0C7: $A5 $FE           lda $FE                                  lda LNUM + 1
$C0C9: $85 $A4           sta $A4                                  sta INCR + 1
$C0CB: $88               dey                                      dey
$C0CC: $F0 $06           beq $C0D4                                beq +
                                                  -
$C0CE: $20 $73 $00       jsr $0073                                jsr CHRGET
$C0D1: $88               dey                                      dey
$C0D2: $D0 $FA           bne $C0CE                                bne -
                                                  +
$C0D4: $20 $1E $C1       jsr $C11E                                jsr START
$C0D7: $90 $05           bcc $C0DE                                bcc +
                                                  
$C0D9: $A2 $0E           ldx #$0E                                 ldx #ILLEGALQUANITY
$C0DB: $4C $37 $A4       jmp $A437                                jmp ERROR
                                                  
                                                  +
$C0DE: $6C $34 $C6       jmp ($C634)                              jmp (IGONE_SV)
                                                  GETLN
$C0E1: $A5 $7A           lda $7A                                  lda TXTPTR
$C0E3: $85 $FB           sta $FB                                  sta NXTLN
$C0E5: $A5 $7B           lda $7B                                  lda TXTPTR + 1
$C0E7: $85 $FC           sta $FC                                  sta NXTLN + 1
$C0E9: $A0 $00           ldy #$00                                 ldy #0
$C0EB: $20 $EC $C2       jsr $C2EC                                jsr GETLINENUM
$C0EE: $60               rts                                      rts
                                                  
$C0EF: $20 $52 $45       .db ' ', 'R', 'E'        RENUMCMD        .byte " RENUMBER",0
$C0F2: $4E $55 $4D       .db 'N', 'U', 'M'        
$C0F5: $42 $45 $52       .db 'B', 'E', 'R'        
$C0F8: $00               .db $00                  
                                                  
                                                  VALIDATE
$C0F9: $48               pha                                      PUSHAY
$C0FA: $98               tya                      
$C0FB: $48               pha                      
$C0FC: $A5 $66           lda $66                                  lda LNUMLEN
$C0FE: $C9 $06           cmp #$06                                 cmp #6
$C100: $B0 $17           bcs $C119                                bcs ++
                                                  
$C102: $C9 $05           cmp #$05                                 cmp #5
$C104: $90 $0F           bcc $C115                                bcc +
                                                  
$C106: $A4 $62           ldy $62                                  ldy LININS
$C108: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C10A: $C9 $37           cmp #$37                                 cmp #'7'
$C10C: $B0 $0B           bcs $C119                                bcs ++
                                                  
$C10E: $C8               iny                                      iny
$C10F: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C111: $C9 $34           cmp #$34                                 cmp #'4'
$C113: $B0 $04           bcs $C119                                bcs ++
                                                  +
$C115: $68               pla                                      POPAY
$C116: $A8               tay                      
$C117: $68               pla                      
$C118: $60               rts                                      rts
                                                  +
$C119: $A2 $0E           ldx #$0E                                 ldx #ILLEGALQUANITY
$C11B: $4C $37 $A4       jmp $A437                                jmp ERROR
                                                  

Processing vars.asm

                                                  ;
                                                  ;   zero page usage
                                                  ;   we will map basic out so we can use
                                                  ;   some basic zero page memory locations
                                                  ;
                                                  MINIDX  = VARNAM                        ;   min index for line lookup 2 bytes
                                                  MAXIDX  = INPPTR                        ;   max index for line lookup 2 bytes
                                                  TBLSZ   = UNUSED2                       ;   size of the table 2 bytes
                                                  LASTIDX = UNUSED2 + 2                   ;   last used index 2 bytes
                                                  LNUMLEN = FACSSGN                       ;   length of line we are searchng for 1 byte
                                                  CURIDX  = INDEX                         ;   current index 2 bytes
                                                  NXTLN   = FREKZP                        ;   next basic statement 2 bytes
                                                  LNUM    = FREKZP + 2                    ;   line num to use 2 bytes
                                                  INCR    = TMPDATA                       ;   line num increment 2 bytes
                                                  BNVAR   = OPPTR                         ;   num to convert to bcd 3 bytes
                                                  BCD     = OPMASK                        ;   bcd number result 3 bytes
                                                  BCDSTR  = OLDLIN                        ;   bcd string result 6 bytes
                                                  INQUOTE = UNUSED1                       ;   holds flag if we are in a string 1 byte
                                                  PREVCH  = DIMFLG                        ;   prev char of line for 'go to' 1 byte
                                                  LDZFLG  = RESHO                         ;   flag for printing leading zeros 1 bytes
                                                  TBLPTR  = FORPNT                        ;   pointer for table 2 bytes
                                                  TBLTMP  = DATPTR                        ;   used to create table 2 bytes
                                                  BCDLEN  = FACEXP                        ;   length of BCD 1 byte
                                                  LININS  = FACHO                         ;   line number insert offset 2 byte
                                                  PRODUCT = FAC2                          ;   multiplication result
                                                  
                                                  .ifdef debug
                                                  DUMPSTR = ARGHO                         ;   use to print strings 2 bytes
                                                  .endif

Processing main.asm

                                                  ;********************************************
                                                  ;*											*
                                                  ;*	START									*
                                                  ;*											*
                                                  ;*	main entry point						*
                                                  ;*											*
                                                  ;********************************************
                                                  START
$C11E: $20 $2F $C1       jsr $C12F                				jsr INITPROG			;	initialize the program
$C121: $20 $A6 $C1       jsr $C1A6                				jsr PASS1				;	perform	pass1
                                                  
                                                  				;
                                                  				;	check for an error
                                                  				;
$C124: $08               php                      				php
$C125: $B0 $03           bcs $C12A                				bcs +
$C127: $20 $63 $C2       jsr $C263                				jsr PASS2				;	perform pass2
                                                  +
$C12A: $20 $84 $C1       jsr $C184                				jsr RESTORE				;	put memory back to normal
$C12D: $28               plp                      				plp
$C12E: $60               rts                      				rts						;	done
                                                  

Processing init.asm

                                                  ;********************************************
                                                  ;*											*
                                                  ;*	INITPROG								*
                                                  ;*											*
                                                  ;*	init the program						*
                                                  ;*											*
                                                  ;*	set nxtlen to start of basic program	*
                                                  ;*	set start line number					*
                                                  ;*	set line increment						*
                                                  ;*	set tblptr and tbltmp to tbl			*
                                                  ;*											*
                                                  ;*	destroys a								*
                                                  ;*											*
                                                  ;********************************************
                                                  INITPROG
$C12F: $A5 $A3           lda $A3                  				lda INCR
$C131: $D0 $09           bne $C13C                				bne ++
$C133: $A5 $A4           lda $A4                  				lda INCR + 1
$C135: $D0 $05           bne $C13C                				bne ++
                                                  +			
$C137: $A2 $0E           ldx #$0E                 				ldx #ILLEGALQUANITY
$C139: $4C $37 $A4       jmp $A437                				jmp ERROR
                                                  +
$C13C: $A9 $7F           lda #$7F                 				lda #127
$C13E: $8D $0D $DC       sta $DC0D                				sta CIAICR
$C141: $8D $0D $DD       sta $DD0D                				sta CI2ICR
                                                  
                                                  				;
                                                  				;	set	NXTLN
                                                  				;
$C144: $A5 $2B           lda $2B                  				lda TXTTAB				;	load start of basic
$C146: $85 $FB           sta $FB                  				sta NXTLN				;	into next line
$C148: $A5 $2C           lda $2C                  				lda TXTTAB + 1
$C14A: $85 $FC           sta $FC                  				sta NXTLN + 1
                                                  
$C14C: $AD $32 $C6       lda $C632                				lda LSTART
$C14F: $85 $FD           sta $FD                  				sta	LNUM
$C151: $AD $33 $C6       lda $C633                				lda LSTART + 1
$C154: $85 $FE           sta $FE                  				sta LNUM + 1
                                                  
                                                  				;
                                                  				;	set table size to 0
                                                  				;
$C156: $A9 $00           lda #$00                 				lda #0
$C158: $85 $57           sta $57                  				sta TBLSZ
$C15A: $85 $58           sta $58                  				sta TBLSZ + 1
                                                  
                                                  				;
                                                  				;	determine	memory	map
                                                  				;
$C15C: $A5 $01           lda $01                  				lda R6510
$C15E: $8D $31 $C6       sta $C631                				sta R6510SV
                                                  
                                                  				;
                                                  				;	check if basic is mapped in
                                                  				;
$C161: $29 $01           and #$01                 				and #%00000001
$C163: $F0 $10           beq $C175                				beq +
                                                  
                                                  				;
                                                  				;	we will switch basic out and use
                                                  				;	$A000	- $BFFF for our table
                                                  				;
$C165: $A9 $00           lda #$00                 				lda #<TBLLOC			;	Set Table location
$C167: $8D $36 $C6       sta $C636                				sta TBL
$C16A: $A9 $A0           lda #$A0                 				lda #>TBLLOC
$C16C: $8D $37 $C6       sta $C637                				sta TBL + 1
                                                  
                                                  				;
                                                  				;	map out basic
                                                  				;
$C16F: $A5 $01           lda $01                  				lda R6510
                                                  				; and #~%00000001
$C171: $29 $FE           and #$FE                 				and #%11111110
$C173: $85 $01           sta $01                  				sta R6510
                                                  +
$C175: $AD $36 $C6       lda $C636                				lda TBL					;	Copy Table location to Table Pointer
$C178: $85 $49           sta $49                  				sta TBLPTR				;	and Table temp pointer
$C17A: $85 $41           sta $41                  				sta TBLTMP
$C17C: $AD $37 $C6       lda $C637                				lda TBL + 1
$C17F: $85 $4A           sta $4A                  				sta TBLPTR + 1
$C181: $85 $42           sta $42                  				sta TBLTMP + 1
$C183: $60               rts                      				rts
                                                  
                                                  ;********************************************
                                                  ;*											*
                                                  ;*	RESTORE									*
                                                  ;*											*
                                                  ;*	restore original memory state			*
                                                  ;*											*
                                                  ;********************************************
                                                  RESTORE
$C184: $AD $31 $C6       lda $C631                				lda R6510SV
$C187: $85 $01           sta $01                  				sta R6510
$C189: $A9 $81           lda #$81                 				lda #129
$C18B: $8D $0D $DC       sta $DC0D                				sta CIAICR
$C18E: $8D $0D $DD       sta $DD0D                				sta CI2ICR
                                                  
$C191: $A5 $37           lda $37                  				lda MEMSIZ
$C193: $85 $33           sta $33                  				sta FRETOP
$C195: $A5 $38           lda $38                  				lda MEMSIZ + 1
$C197: $85 $34           sta $34                  				sta FRETOP + 1
                                                  
$C199: $A5 $31           lda $31                  				lda STREND
$C19B: $85 $2D           sta $2D                  				sta VARTAB
$C19D: $85 $2F           sta $2F                  				sta ARYTAB
$C19F: $A5 $32           lda $32                  				lda STREND + 1
$C1A1: $85 $2E           sta $2E                  				sta VARTAB + 1
$C1A3: $85 $30           sta $30                  				sta ARYTAB + 1
                                                  
$C1A5: $60               rts                      				rts
                                                                  

Processing pass1.asm

                                                  ;****************************************
                                                  ;*                                      *
                                                  ;* PASS1                                *
                                                  ;*                                      *
                                                  ;*  create table for old and new lines  *
                                                  ;*  update line numbers                 *
                                                  ;*  gotos etc will be fixes in pass2    *
                                                  ;*                                      *
                                                  ;****************************************
                                                  PASS1
                                                                  ;
                                                                  ; check for last line of basic
                                                                  ;
$C1A6: $20 $B1 $C5       jsr $C5B1                                jsr LASTLINE
$C1A9: $D0 $03           bne $C1AE                                bne +
$C1AB: $4C $3C $C2       jmp $C23C                                jmp ++++
                                                  +
                                                                  ;
                                                                  ; save original line number in table
                                                                  ;
$C1AE: $20 $3E $C2       jsr $C23E                                jsr SAVETBL
                                                  
                                                                  ;
                                                                  ; update the line number in basic
                                                                  ;
$C1B1: $A0 $02           ldy #$02                                 ldy #LNOFF
$C1B3: $A5 $FD           lda $FD                                  lda LNUM
$C1B5: $91 $FB           sta ($FB),y                              sta (NXTLN),y
$C1B7: $A5 $FE           lda $FE                                  lda LNUM + 1
$C1B9: $C8               iny                                      iny
$C1BA: $91 $FB           sta ($FB),y                              sta (NXTLN),y
                                                  
                                                                  ;
                                                                  ; add line increment to line number
                                                                  ;
$C1BC: $18               clc                                      clc
$C1BD: $A5 $FD           lda $FD                                  lda LNUM
$C1BF: $65 $A3           adc $A3                                  adc INCR
$C1C1: $85 $FD           sta $FD                                  sta LNUM
$C1C3: $A5 $FE           lda $FE                                  lda LNUM + 1
$C1C5: $65 $A4           adc $A4                                  adc INCR + 1
$C1C7: $85 $FE           sta $FE                                  sta LNUM + 1
                                                  
$C1C9: $90 $55           bcc $C220                                bcc ++
                                                  
                                                                  ;
                                                                  ;   We wrapped. Line number too big
                                                                  ;   restore original lines and then error out
                                                  
                                                                  ;
                                                                  ;   set NXTLN
                                                                  ;
$C1CB: $A5 $2B           lda $2B                                  lda TXTTAB              ;   load start of basic
$C1CD: $85 $FB           sta $FB                                  sta NXTLN               ;   into next line
$C1CF: $A5 $2C           lda $2C                                  lda TXTTAB + 1
$C1D1: $85 $FC           sta $FC                                  sta NXTLN + 1
                                                  
$C1D3: $AD $36 $C6       lda $C636                                lda TBL
$C1D6: $85 $41           sta $41                                  sta TBLTMP
$C1D8: $AD $37 $C6       lda $C637                                lda TBL + 1
$C1DB: $85 $42           sta $42                                  sta TBLTMP + 1
                                                  -
$C1DD: $A0 $00           ldy #$00                                 ldy #0
$C1DF: $B1 $41           lda ($41),y                              lda (TBLTMP),y
$C1E1: $A0 $02           ldy #$02                                 ldy #LNOFF
$C1E3: $91 $FB           sta ($FB),y                              sta (NXTLN),y
$C1E5: $A0 $01           ldy #$01                                 ldy #1
$C1E7: $B1 $41           lda ($41),y                              lda (TBLTMP),y
$C1E9: $A0 $03           ldy #$03                                 ldy #LNOFF + 1
$C1EB: $91 $FB           sta ($FB),y                              sta (NXTLN),y
                                                  
$C1ED: $A5 $57           lda $57                                  lda TBLSZ
$C1EF: $D0 $06           bne $C1F7                                bne +
$C1F1: $A5 $58           lda $58                                  lda TBLSZ + 1
$C1F3: $D0 $02           bne $C1F7                                bne +
                                                  
$C1F5: $38               sec                                      sec
$C1F6: $60               rts                                      rts
                                                  +
$C1F7: $38               sec                                      sec
$C1F8: $A5 $57           lda $57                                  lda TBLSZ
$C1FA: $E9 $01           sbc #$01                                 sbc #<1
$C1FC: $85 $57           sta $57                                  sta TBLSZ
$C1FE: $A5 $58           lda $58                                  lda TBLSZ + 1
$C200: $E9 $00           sbc #$00                                 sbc #>1
$C202: $85 $58           sta $58                                  sta TBLSZ + 1
                                                  
$C204: $18               clc                                      clc
$C205: $A5 $41           lda $41                                  lda TBLTMP
$C207: $69 $02           adc #$02                                 adc #<2
$C209: $85 $41           sta $41                                  sta TBLTMP
$C20B: $A5 $42           lda $42                                  lda TBLTMP + 1
$C20D: $69 $00           adc #$00                                 adc #>2
$C20F: $85 $42           sta $42                                  sta TBLTMP + 1
                                                  
$C211: $A0 $00           ldy #$00                                 ldy #NXOFF
$C213: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C215: $AA               tax                                      tax
$C216: $C8               iny                                      iny
$C217: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C219: $86 $FB           stx $FB                                  stx NXTLN
$C21B: $85 $FC           sta $FC                                  sta NXTLN + 1
$C21D: $4C $DD $C1       jmp $C1DD                                jmp -
                                                  
                                                                  ;
                                                                  ; get the next line ptr
                                                                  ; store in nxtln
                                                                  ;
                                                  +
$C220: $A0 $00           ldy #$00                                 ldy #NXOFF
$C222: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C224: $AA               tax                                      tax
$C225: $C8               iny                                      iny
$C226: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C228: $86 $FB           stx $FB                                  stx NXTLN
$C22A: $85 $FC           sta $FC                                  sta NXTLN + 1
                                                  
                                                                  ;
                                                                  ; increment table size
                                                                  ;
$C22C: $18               clc                                      clc
$C22D: $A5 $57           lda $57                                  lda TBLSZ
$C22F: $69 $01           adc #$01                                 adc #<1
$C231: $85 $57           sta $57                                  sta TBLSZ
$C233: $A5 $58           lda $58                                  lda TBLSZ + 1
$C235: $69 $00           adc #$00                                 adc #>1
$C237: $85 $58           sta $58                                  sta TBLSZ + 1
$C239: $4C $A6 $C1       jmp $C1A6                                jmp PASS1
                                                  
                                                  +
                                                                  ;
                                                                  ; clear carry to signal success
                                                                  ;
$C23C: $18               clc                                      clc
$C23D: $60               rts                                      rts
                                                  
                                                  ;****************************************
                                                  ;*                                      *
                                                  ;* SAVETBL                              *
                                                  ;*                                      *
                                                  ;*  add the cuurent line to the table   *
                                                  ;*  nxtln must point to start of line   *
                                                  ;*                                      *
                                                  ;*  destroys a,y                        *
                                                  ;*                                      *
                                                  ;****************************************
                                                  SAVETBL
                                                                  ;
                                                                  ; move line number to bnvar
                                                                  ;
$C23E: $A0 $02           ldy #$02                                 ldy #LNOFF
$C240: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C242: $AA               tax                                      tax
$C243: $C8               iny                                      iny
$C244: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C246: $86 $4B           stx $4B                                  stx BNVAR
$C248: $85 $4C           sta $4C                                  sta BNVAR + 1
                                                  
                                                                  ;
                                                                  ; tbltmp points to next spot in table
                                                                  ; store line number contained bnvar in table
                                                                  ;
$C24A: $A0 $00           ldy #$00                                 ldy #0
$C24C: $A5 $4B           lda $4B                                  lda BNVAR
$C24E: $91 $41           sta ($41),y                              sta (TBLTMP),y
$C250: $A5 $4C           lda $4C                                  lda BNVAR + 1
$C252: $C8               iny                                      iny
$C253: $91 $41           sta ($41),y                              sta (TBLTMP),y
                                                  
                                                                  ;
                                                                  ; increment table ptr by 2 bytes
                                                                  ;
$C255: $18               clc                                      clc
$C256: $A5 $41           lda $41                                  lda TBLTMP
$C258: $69 $02           adc #$02                                 adc #<2
$C25A: $85 $41           sta $41                                  sta TBLTMP
$C25C: $A5 $42           lda $42                                  lda TBLTMP + 1
$C25E: $69 $00           adc #$00                                 adc #>2
$C260: $85 $42           sta $42                                  sta TBLTMP + 1
$C262: $60               rts                                      rts
                                                  

Processing pass2.asm

                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* PASS2                                    *
                                                  ;*                                          *
                                                  ;*  reset current line to beginning         *
                                                  ;*  find goto gosub then go to              *
                                                  ;*  lookup line in table                    *
                                                  ;*  if it fits replace if not move lines    *
                                                  ;*  so it does fit                          *
                                                  ;*                                          *
                                                  ;********************************************
                                                  PASS2
$C263: $AD $20 $D0       lda $D020                                lda BORDER
$C266: $48               pha                                      pha
                                                  
                                                                  ;
                                                                  ;   set NXTLN
                                                                  ;
$C267: $A5 $2B           lda $2B                                  lda TXTTAB              ;   load start of basic
$C269: $85 $FB           sta $FB                                  sta NXTLN               ;   into next line
$C26B: $A5 $2C           lda $2C                                  lda TXTTAB + 1
$C26D: $85 $FC           sta $FC                                  sta NXTLN + 1
                                                  
                                                                  ;
                                                                  ;   clear quote flag
                                                                  ;
                                                  -
$C26F: $A9 $00           lda #$00                                 lda #0
$C271: $85 $02           sta $02                                  sta INQUOTE
                                                  
                                                                  ;
                                                                  ;   check for last line of basic
                                                                  ;
$C273: $20 $B1 $C5       jsr $C5B1                                jsr LASTLINE
$C276: $D0 $05           bne $C27D                                bne +                   ;   continue
                                                  
$C278: $68               pla                                      pla
$C279: $8D $20 $D0       sta $D020                                sta BORDER
                                                  
                                                                  ;
                                                                  ;   exit
                                                                  ;
$C27C: $60               rts                                      rts
                                                  
                                                                  ;
                                                                  ;   init y to point to first char in line   -1
                                                                  ;
                                                  +
$C27D: $A0 $03           ldy #$03                                 ldy #TXTOFF - 1
$C27F: $A9 $00           lda #$00                                 lda #0
                                                  -
                                                                  ;
                                                                  ;   reg a contains prevch
                                                                  ;   skip spaces
                                                                  ;
$C281: $C9 $20           cmp #$20                                 cmp #SPACE
$C283: $F0 $02           beq $C287                                beq +                   ;   dont save a in prevch
                                                  
                                                                  ;
                                                                  ;   save non space
                                                                  ;
$C285: $85 $0C           sta $0C                                  sta PREVCH
                                                  +
                                                                  ;
                                                                  ;   get the next char in line
                                                                  ;
$C287: $C8               iny                                      iny                     ;   increment offset
$C288: $B1 $FB           lda ($FB),y                              lda (NXTLN),y           ;   get the char
$C28A: $F0 $4E           beq $C2DA                                beq +++                 ;   00 signifies eol
                                                  
                                                                  ;
                                                                  ;   see if we got a quote
                                                                  ;
$C28C: $C9 $22           cmp #$22                                 cmp #QUOTE
$C28E: $F0 $41           beq $C2D1                                beq ++
                                                  
                                                                  ;
                                                                  ;   see if we are in a string
                                                                  ;
$C290: $A6 $02           ldx $02                                  ldx INQUOTE
$C292: $D0 $ED           bne $C281                                bne -                   ;   if we are in a string skip
                                                  
                                                                  ;
                                                                  ;   start looking for tokens
                                                                  ;
$C294: $C9 $89           cmp #$89                                 cmp #GOTO_TOK           ;   check for goto
$C296: $F0 $12           beq $C2AA                                beq +
$C298: $C9 $8D           cmp #$8D                                 cmp #GOSUB_TOK          ;   check for gosub
$C29A: $F0 $0E           beq $C2AA                                beq +
$C29C: $C9 $A7           cmp #$A7                                 cmp #THEN_TOK           ;   check for then
$C29E: $F0 $0A           beq $C2AA                                beq +
$C2A0: $C9 $A4           cmp #$A4                                 cmp #TO_TOK             ;   check for to
$C2A2: $D0 $DD           bne $C281                                bne -
$C2A4: $A6 $0C           ldx $0C                                  ldx PREVCH              ;   check for go before to
$C2A6: $E0 $CB           cpx #$CB                                 cpx #GO_TOK
$C2A8: $D0 $D7           bne $C281                                bne -
                                                  +
                                                  -
$C2AA: $C8               iny                                      iny                     ;   increment offset
$C2AB: $B1 $FB           lda ($FB),y                              lda (NXTLN),y           ;   get the char
$C2AD: $F0 $2B           beq $C2DA                                beq ++                  ;   00 signifies eol
                                                  
$C2AF: $C9 $3A           cmp #$3A                                 cmp #':'                ;   if we have a colon continue with rest of line
$C2B1: $F0 $CE           beq $C281                                beq --
                                                  
$C2B3: $C9 $20           cmp #$20                                 cmp #SPACE              ;   if we have a space skip it
$C2B5: $F0 $F3           beq $C2AA                                beq -
                                                  
$C2B7: $C9 $2C           cmp #$2C                                 cmp #','                ;   if we have a comma skip it
$C2B9: $F0 $EF           beq $C2AA                                beq -
                                                  
$C2BB: $C9 $30           cmp #$30                                 cmp #'0'
$C2BD: $90 $C2           bcc $C281                                bcc --                  ;   less than '0'
$C2BF: $C9 $3A           cmp #$3A                                 cmp #'9' + 1            ;   greater than '9'
$C2C1: $B0 $BE           bcs $C281                                bcs --
                                                  
                                                                  ;
                                                                  ;   we have a line number
                                                                  ;
                                                  
$C2C3: $20 $EC $C2       jsr $C2EC                                jsr GETLINENUM          ;   parse linenumber in basic line
$C2C6: $20 $34 $C3       jsr $C334                                jsr FINDLINENUM         ;   look up old linenumber and get new line number
$C2C9: $20 $BB $C3       jsr $C3BB                                jsr INSERTLINENUM       ;   insert the new line number
                                                  
$C2CC: $8A               txa                                      txa                     ;   x contains current pointer in line
$C2CD: $A8               tay                                      tay
$C2CE: $4C $AA $C2       jmp $C2AA                                jmp -
                                                  
                                                                  ;
                                                                  ;   we got a quote
                                                                  ;
                                                  +
$C2D1: $A5 $02           lda $02                                  lda INQUOTE             ;   load quote flag
$C2D3: $49 $01           eor #$01                                 eor #1                  ;   flip the bit
$C2D5: $85 $02           sta $02                                  sta INQUOTE             ;   save the result
$C2D7: $4C $81 $C2       jmp $C281                                jmp --                  ;   continue with rest of line
                                                  
                                                                  ;
                                                                  ;   get the next line ptr
                                                                  ;   store in nxtln
                                                                  ;
                                                  +
$C2DA: $A0 $00           ldy #$00                                 ldy #NXOFF              ; offset from line offset
$C2DC: $B1 $FB           lda ($FB),y                              lda (NXTLN),y           ; load next line offset
$C2DE: $AA               tax                                      tax                     ; save in x
$C2DF: $C8               iny                                      iny
$C2E0: $B1 $FB           lda ($FB),y                              lda (NXTLN),y           ; get next byte
$C2E2: $86 $FB           stx $FB                                  stx NXTLN               ; set next line
$C2E4: $85 $FC           sta $FC                                  sta NXTLN + 1
                                                  
$C2E6: $EE $20 $D0       inc $D020                                INC BORDER
                                                  
$C2E9: $4C $6F $C2       jmp $C26F                                jmp ---
                                                  

Processing getlinenum.asm

                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* GETLINENUM                               *
                                                  ;*                                          *
                                                  ;*  get line number in basic line           *
                                                  ;*  (nxtln),y points to PETACII lnumber     *
                                                  ;*                                          *
                                                  ;*  on exit lnum = line number              *
                                                  ;*          LININS = y offset               *
                                                  ;*                                          *
                                                  ;********************************************
                                                  GETLINENUM
                                                                  ;
                                                                  ;   clear lnum
                                                                  ;
$C2EC: $A9 $00           lda #$00                                 lda #0
$C2EE: $85 $FD           sta $FD                                  sta LNUM
$C2F0: $85 $FE           sta $FE                                  sta LNUM + 1
$C2F2: $85 $66           sta $66                                  sta LNUMLEN
$C2F4: $84 $62           sty $62                                  sty LININS
                                                  -
$C2F6: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C2F8: $C9 $30           cmp #$30                                 cmp #'0'
$C2FA: $90 $37           bcc $C333                                bcc +
$C2FC: $C9 $3A           cmp #$3A                                 cmp #'9' + 1
$C2FE: $B0 $33           bcs $C333                                bcs +
                                                  
                                                                  ;
                                                                  ;   increment line length
                                                                  ;
$C300: $E6 $66           inc $66                                  inc LNUMLEN
                                                  
                                                                  ;
                                                                  ;   a now contains a digit
                                                                  ;   multiply lnum * 10
                                                                  ;   add digit
                                                                  ;
$C302: $48               pha                                      PUSHAY                  ;   save registers
$C303: $98               tya                      
$C304: $48               pha                      
$C305: $06 $FD           asl $FD                                  MULT10 LNUM             ;   multiply by 10
$C307: $26 $FE           rol $FE                  
$C309: $A6 $FD           ldx $FD                  
$C30B: $A4 $FE           ldy $FE                  
$C30D: $06 $FD           asl $FD                  
$C30F: $26 $FE           rol $FE                  
$C311: $06 $FD           asl $FD                  
$C313: $26 $FE           rol $FE                  
$C315: $18               clc                      
$C316: $8A               txa                      
$C317: $65 $FD           adc $FD                  
$C319: $85 $FD           sta $FD                  
$C31B: $98               tya                      
$C31C: $65 $FE           adc $FE                  
$C31E: $85 $FE           sta $FE                  
$C320: $68               pla                                      POPAY                   ;   restore registers
$C321: $A8               tay                      
$C322: $68               pla                      
                                                  
$C323: $29 $CF           and #$CF                                 and #~'0'               ;   mask off string
$C325: $18               clc                                      clc                     ;   add to lnum
$C326: $65 $FD           adc $FD                                  adc LNUM
$C328: $85 $FD           sta $FD                                  sta LNUM
$C32A: $A5 $FE           lda $FE                                  lda LNUM + 1
$C32C: $69 $00           adc #$00                                 adc #0
$C32E: $85 $FE           sta $FE                                  sta LNUM + 1
$C330: $C8               iny                                      iny
$C331: $D0 $C3           bne $C2F6                                bne -                   ;   get the next digit
                                                  +
$C333: $60               rts                                      rts
                                                  

Processing findlinenum.asm

                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* FINDLINENUM                              *
                                                  ;*                                          *
                                                  ;*  find line number in a sorted table      *
                                                  ;*  using a binary search                   *
                                                  ;*                                          *
                                                  ;********************************************
                                                  FINDLINENUM
                                                                  ;
                                                                  ;   init maxidx
                                                                  ;
$C334: $A5 $57           lda $57                                  lda TBLSZ
$C336: $85 $43           sta $43                                  sta MAXIDX
$C338: $A5 $58           lda $58                                  lda TBLSZ + 1
$C33A: $85 $44           sta $44                                  sta MAXIDX + 1
                                                  
                                                                  ;
                                                                  ;   init lastidx
                                                                  ;
$C33C: $A9 $FF           lda #$FF                                 lda #$FF
$C33E: $85 $59           sta $59                                  sta LASTIDX
$C340: $85 $5A           sta $5A                                  sta LASTIDX + 1
                                                  
                                                                  ;
                                                                  ;   convert maxidx to bytes
                                                                  ;
$C342: $38               sec                                      sec
$C343: $06 $43           asl $43                                  asl MAXIDX
$C345: $26 $44           rol $44                                  rol MAXIDX  + 1
                                                  
                                                                  ;
                                                                  ;   init minidx
                                                                  ;
$C347: $A9 $00           lda #$00                                 lda #0
$C349: $85 $45           sta $45                                  sta MINIDX
$C34B: $85 $46           sta $46                                  sta MINIDX  + 1
                                                  
                                                  .ifdef debug
                                                                  jsr DUMP_LN
                                                                  jsr DUMP_STAR
                                                  .endif
                                                  -
                                                  .ifdef debug
                                                                  jsr DUMP_MX
                                                                  jsr DUMP_MN
                                                                  jsr DUMP_TS
                                                  .endif
                                                                  ;
                                                                  ;   calculate next index to table
                                                                  ;   table is sorted so binary search
                                                                  ;   maxidx  - minidx
                                                                  ;
$C34D: $38               sec                                      sec
$C34E: $A5 $43           lda $43                                  lda MAXIDX              ;   curidx = maxidx - minidx
$C350: $E5 $45           sbc $45                                  sbc MINIDX
$C352: $85 $22           sta $22                                  sta CURIDX
$C354: $A5 $44           lda $44                                  lda MAXIDX + 1
$C356: $E5 $46           sbc $46                                  sbc MINIDX + 1
$C358: $85 $23           sta $23                                  sta CURIDX + 1
                                                  
                                                                  ;
                                                                  ;   divide by 2
                                                                  ;
$C35A: $46 $23           lsr $23                                  lsr CURIDX  + 1         ;   curidx >> 1
$C35C: $66 $22           ror $22                                  ror CURIDX
                                                  
                                                                  ;
                                                                  ;   add minidx
                                                                  ;
$C35E: $18               clc                                      clc                     ;   curidx += minidx
$C35F: $A5 $22           lda $22                                  lda CURIDX
$C361: $65 $45           adc $45                                  adc MINIDX
$C363: $85 $22           sta $22                                  sta CURIDX
$C365: $A5 $23           lda $23                                  lda CURIDX  + 1
$C367: $65 $46           adc $46                                  adc MINIDX  + 1
$C369: $85 $23           sta $23                                  sta CURIDX  + 1
                                                  
                                                                  ;
                                                                  ;   make CURIDX even (low byte)
                                                                  ;
$C36B: $A5 $22           lda $22                                  lda CURIDX              ;   curidx &= 0xFFFE
$C36D: $29 $FE           and #$FE                                 and #~%00000001
$C36F: $85 $22           sta $22                                  sta CURIDX
                                                  
                                                                  ;
                                                                  ;   check to see if we tried this already
                                                                  ;
$C371: $C5 $59           cmp $59                                  cmp LASTIDX
$C373: $D0 $07           bne $C37C                                bne +
$C375: $A5 $23           lda $23                                  lda CURIDX  + 1
$C377: $C5 $5A           cmp $5A                                  cmp LASTIDX + 1
$C379: $D0 $01           bne $C37C                                bne +
                                                  
                                                                  ;
                                                                  ;   we can't find the line
                                                                  ;
$C37B: $60               rts                                      rts
                                                  +
                                                                  ;
                                                                  ;   save current index
                                                                  ;
$C37C: $A5 $22           lda $22                                  lda CURIDX
$C37E: $85 $59           sta $59                                  sta LASTIDX
$C380: $A5 $23           lda $23                                  lda CURIDX + 1
$C382: $85 $5A           sta $5A                                  sta LASTIDX + 1
                                                  
                                                                  ;
                                                                  ;   load tbl[curinx]
                                                                  ;
$C384: $18               clc                                      clc
$C385: $AD $36 $C6       lda $C636                                lda TBL
$C388: $65 $22           adc $22                                  adc CURIDX
$C38A: $85 $49           sta $49                                  sta TBLPTR
$C38C: $AD $37 $C6       lda $C637                                lda TBL + 1
$C38F: $65 $23           adc $23                                  adc CURIDX + 1
$C391: $85 $4A           sta $4A                                  sta TBLPTR + 1
                                                  .ifdef debug
                                                                  jsr DUMP_NEWLINE
                                                                  jsr DUMP_I
                                                                  jsr DUMP_TP
                                                                  jsr DUMP_TE
                                                  .endif
                                                                  ;
                                                                  ;   compare high byte
                                                                  ;
$C393: $A0 $01           ldy #$01                                 ldy #1
$C395: $B1 $49           lda ($49),y                              lda (TBLPTR),y
$C397: $C5 $FE           cmp $FE                                  cmp LNUM + 1
$C399: $D0 $07           bne $C3A2                                bne +
                                                                  ;
                                                                  ;   compare low byte
                                                                  ;
$C39B: $88               dey                                      dey
$C39C: $B1 $49           lda ($49),y                              lda (TBLPTR),y
$C39E: $C5 $FD           cmp $FD                                  cmp LNUM
$C3A0: $F0 $18           beq $C3BA                                beq +++
                                                  +
                                                                  ;
                                                                  ;   not equal
                                                                  ;
$C3A2: $90 $0B           bcc $C3AF                                bcc +
                                                  .ifdef debug
                                                                  jsr DUMP_PLUS
                                                  .endif
                                                                  ;
                                                                  ;   table entry greater than lnum
                                                                  ;
$C3A4: $A5 $22           lda $22                                  lda CURIDX
$C3A6: $85 $43           sta $43                                  sta MAXIDX
$C3A8: $A5 $23           lda $23                                  lda CURIDX + 1
$C3AA: $85 $44           sta $44                                  sta MAXIDX + 1
$C3AC: $4C $4D $C3       jmp $C34D                                jmp -                   ;   try next guess
                                                  +
                                                  .ifdef debug
                                                                  jsr DUMP_MINUS
                                                  .endif
                                                                  ;
                                                                  ;   table entry less than lnum
                                                                  ;
$C3AF: $A5 $22           lda $22                                  lda CURIDX
$C3B1: $85 $45           sta $45                                  sta MINIDX
$C3B3: $A5 $23           lda $23                                  lda CURIDX + 1
$C3B5: $85 $46           sta $46                                  sta MINIDX + 1
$C3B7: $4C $4D $C3       jmp $C34D                                jmp -                   ;   try next guess
                                                  +
                                                  .ifdef debug
                                                                  jsr DUMP_FOUNDLINE
                                                  .endif
$C3BA: $60               rts                                      rts
                                                  

Processing insertlinenum.asm

                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* INSERTLINENUM                            *
                                                  ;*                                          *
                                                  ;*  insert new linenumber in basic program  *
                                                  ;*                                          *
                                                  ;********************************************
                                                  INSERTLINENUM
$C3BB: $48               pha                                      PUSHAY
$C3BC: $98               tya                      
$C3BD: $48               pha                      
                                                                  ;
                                                                  ;   we found the line
                                                                  ;   now calculate the new line number based on index
                                                                  ;
$C3BE: $46 $23           lsr $23                                  lsr CURIDX + 1          ; curidx >>= 1
$C3C0: $66 $22           ror $22                                  ror CURIDX
                                                  
                                                                  ;
                                                                  ; multiply by line increment and store in product
                                                                  ;
$C3C2: $A5 $A3           lda $A3                                  MULT16 CURIDX, INCR, PRODUCT
$C3C4: $48               pha                      
$C3C5: $A5 $A4           lda $A4                  
$C3C7: $48               pha                      
$C3C8: $A9 $00           lda #$00                 
$C3CA: $85 $6B           sta $6B                  
$C3CC: $85 $6C           sta $6C                  
$C3CE: $A2 $10           ldx #$10                 
$C3D0: $46 $A4           lsr $A4                  
$C3D2: $66 $A3           ror $A3                  
$C3D4: $90 $51           bcc $C427                
$C3D6: $A5 $6B           lda $6B                  
$C3D8: $18               clc                      
$C3D9: $65 $22           adc $22                  
$C3DB: $85 $6B           sta $6B                  
$C3DD: $A5 $6C           lda $6C                  
$C3DF: $65 $23           adc $23                  
$C3E1: $6A               ror                      
$C3E2: $85 $6C           sta $6C                  
$C3E4: $66 $6B           ror $6B                  
$C3E6: $66 $6A           ror $6A                  
$C3E8: $66 $69           ror $69                  
$C3EA: $CA               dex                      
$C3EB: $D0 $E3           bne $C3D0                
$C3ED: $68               pla                      
$C3EE: $85 $A4           sta $A4                  
$C3F0: $68               pla                      
$C3F1: $85 $A3           sta $A3                  
                                                  
                                                                  ;
                                                                  ;   add start line
                                                                  ;   store in BNVAR
                                                                  ;
$C3F3: $18               clc                                      clc
$C3F4: $AD $32 $C6       lda $C632                                lda LSTART
$C3F7: $65 $69           adc $69                                  adc PRODUCT
$C3F9: $85 $4B           sta $4B                                  sta BNVAR
$C3FB: $AD $33 $C6       lda $C633                                lda LSTART + 1
$C3FE: $65 $6A           adc $6A                                  adc PRODUCT + 1
$C400: $85 $4C           sta $4C                                  sta BNVAR + 1
                                                  
$C402: $20 $BB $C5       jsr $C5BB                                jsr BINBCD16
                                                  .ifdef debug
                                                                  PUSHAY
                                                                  jsr PRINTBCDSTR
                                                                  POPAY
                                                  .endif
$C405: $20 $11 $C6       jsr $C611                                jsr BCDLENGTH
                                                  .ifdef debug
                                                                  jsr DUMP_LENGTH
                                                                  lda BCDLEN
                                                                  jsr DUMP_BYTE
                                                                  jsr DUMP_EQUALS
                                                                  lda LNUMLEN
                                                                  jsr DUMP_BYTE
                                                                  jsr DUMP_NEWLINE
                                                  .endif
$C408: $A5 $66           lda $66                                  lda LNUMLEN
$C40A: $C5 $61           cmp $61                                  cmp BCDLEN
$C40C: $D0 $19           bne $C427                                bne +
                                                  
                                                                  ;
                                                                  ;   line numbers are the same length
                                                                  ;
$C40E: $A4 $62           ldy $62                                  ldy LININS
                                                                  ;
                                                                  ;   get offset to bcdstring
                                                                  ;
                                                  -
$C410: $38               sec                                      sec
$C411: $A9 $05           lda #$05                                 lda #5
$C413: $E5 $61           sbc $61                                  sbc BCDLEN
$C415: $AA               tax                                      tax
                                                                  ;
                                                                  ;   copy string into line
                                                                  ;
                                                  -
$C416: $B5 $3B           lda $3B,x                                lda BCDSTR,x
$C418: $91 $FB           sta ($FB),y                              sta (NXTLN),y
$C41A: $C8               iny                                      iny
$C41B: $E8               inx                                      inx
$C41C: $E0 $05           cpx #$05                                 cpx #5
$C41E: $D0 $F6           bne $C416                                bne -
                                                  
$C420: $98               tya                                      tya
$C421: $AA               tax                                      tax
$C422: $CA               dex                                      dex
                                                  
$C423: $68               pla                                      POPAY
$C424: $A8               tay                      
$C425: $68               pla                      
$C426: $60               rts                                      rts
                                                  +
$C427: $90 $07           bcc $C430                                bcc +
                                                  
                                                                  ;
                                                                  ;   new line number is smaller
                                                                  ;
$C429: $20 $36 $C4       jsr $C436                                jsr MOVELINESDOWN
                                                  -
$C42C: $A4 $62           ldy $62                                  ldy LININS
$C42E: $D0 $E0           bne $C410                                bne ---
                                                  
                                                                  ;
                                                                  ;   new line number is larger
                                                                  ;
                                                  +
$C430: $20 $DB $C4       jsr $C4DB                                jsr MOVELINESUP
$C433: $4C $2C $C4       jmp $C42C                                jmp -
                                                  

Processing movelines.asm

                                                  
                                                  FROM    = MINIDX
                                                  TO      = MAXIDX
                                                  SIZEL   = CURIDX
                                                  SIZEH   = CURIDX + 1
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* MOVELINESDOWN                            *
                                                  ;*                                          *
                                                  ;*  move basic lines to get rid of extra    *
                                                  ;*  space                                   *
                                                  ;*                                          *
                                                  ;********************************************
                                                  MOVELINESDOWN
                                                                  ;
                                                                  ;   save nxtln
                                                                  ;
$C436: $A0 $01           ldy #$01                                 SAVEZP NXTLN,+,2
$C438: $B9 $FB $00       lda $00FB,y              
$C43B: $99 $D9 $C4       sta $C4D9,y              
$C43E: $88               dey                      
$C43F: $10 $F7           bpl $C438                
                                                  
                                                                  ;
                                                                  ;   set MINIDX to endptr
                                                                  ;
$C441: $A5 $FB           lda $FB                                  lda NXTLN
$C443: $85 $45           sta $45                                  sta MINIDX
$C445: $A5 $FC           lda $FC                                  lda NXTLN + 1
$C447: $85 $46           sta $46                                  sta MINIDX + 1
$C449: $18               clc                                      clc
$C44A: $A5 $62           lda $62                                  lda LININS
$C44C: $65 $45           adc $45                                  adc MINIDX
$C44E: $85 $45           sta $45                                  sta MINIDX
$C450: $A9 $00           lda #$00                                 lda #0
$C452: $65 $46           adc $46                                  adc MINIDX + 1
$C454: $85 $46           sta $46                                  sta MINIDX + 1
                                                  
                                                                  ;
                                                                  ;   find out how many more bytes we need
                                                                  ;
$C456: $38               sec                                      sec
$C457: $A5 $66           lda $66                                  lda LNUMLEN
$C459: $E5 $61           sbc $61                                  sbc BCDLEN
$C45B: $85 $59           sta $59                                  sta LASTIDX
                                                  
                                                                  ;
                                                                  ;   fix basic variables
                                                                  ;
$C45D: $38               sec                                      sec
$C45E: $A5 $31           lda $31                                  lda STREND
$C460: $E5 $59           sbc $59                                  sbc LASTIDX
$C462: $85 $31           sta $31                                  sta STREND
$C464: $A5 $32           lda $32                                  lda STREND+1
$C466: $E9 $00           sbc #$00                                 sbc #0
$C468: $85 $32           sta $32                                  sta STREND+1
                                                  
                                                                  ;
                                                                  ;   subtract from the line start pointers
                                                                  ;
                                                  -
$C46A: $A0 $00           ldy #$00                                 ldy #NXOFF
$C46C: $38               sec                                      sec
$C46D: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C46F: $85 $43           sta $43                                  sta MAXIDX
$C471: $E5 $59           sbc $59                                  sbc LASTIDX
$C473: $91 $FB           sta ($FB),y                              sta (NXTLN),y
$C475: $C8               iny                                      iny
$C476: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C478: $85 $44           sta $44                                  sta MAXIDX + 1
$C47A: $E9 $00           sbc #$00                                 sbc #0
$C47C: $91 $FB           sta ($FB),y                              sta (NXTLN),y
                                                  
                                                                  ;
                                                                  ;   copy maxidx to nxtln
                                                                  ;
$C47E: $A5 $43           lda $43                                  lda MAXIDX
$C480: $85 $FB           sta $FB                                  sta NXTLN
$C482: $A5 $44           lda $44                                  lda MAXIDX + 1
$C484: $85 $FC           sta $FC                                  sta NXTLN + 1
                                                  
                                                                  ;
                                                                  ;   check for end of basic
                                                                  ;
$C486: $20 $B1 $C5       jsr $C5B1                                jsr LASTLINE
$C489: $D0 $DF           bne $C46A                                bne -
                                                  
                                                                  ;
                                                                  ;   figure out numbytes to move
                                                                  ;
$C48B: $38               sec                                      sec
$C48C: $A5 $43           lda $43                                  lda MAXIDX
$C48E: $E5 $45           sbc $45                                  sbc MINIDX
$C490: $85 $22           sta $22                                  sta CURIDX
$C492: $A5 $44           lda $44                                  lda MAXIDX + 1
$C494: $E5 $46           sbc $46                                  sbc MINIDX + 1
$C496: $85 $23           sta $23                                  sta CURIDX + 1
                                                  
                                                                  ;
                                                                  ;   add EOL and end of basic marker
                                                                  ;
$C498: $18               clc                                      clc
$C499: $A5 $22           lda $22                                  lda CURIDX
$C49B: $69 $04           adc #$04                                 adc #4
$C49D: $85 $22           sta $22                                  sta CURIDX
$C49F: $A5 $23           lda $23                                  lda CURIDX + 1
$C4A1: $69 $00           adc #$00                                 adc #0
$C4A3: $85 $23           sta $23                                  sta CURIDX + 1
                                                  
                                                                  ;
                                                                  ;   set max to new dest address
                                                                  ;
$C4A5: $18               clc                                      clc
$C4A6: $A5 $45           lda $45                                  lda MINIDX
$C4A8: $65 $59           adc $59                                  adc LASTIDX
$C4AA: $85 $43           sta $43                                  sta MAXIDX
$C4AC: $A5 $46           lda $46                                  lda MINIDX + 1
$C4AE: $69 $00           adc #$00                                 adc #0
$C4B0: $85 $44           sta $44                                  sta MAXIDX + 1
                                                  
                                                                  ;
                                                                  ;   we need to swap maxidx and minidx
                                                                  ;
$C4B2: $A5 $45           lda $45                                  lda MINIDX
$C4B4: $85 $FB           sta $FB                                  sta NXTLN
$C4B6: $A5 $46           lda $46                                  lda MINIDX + 1
$C4B8: $85 $FC           sta $FC                                  sta NXTLN + 1
$C4BA: $A5 $43           lda $43                                  lda MAXIDX
$C4BC: $85 $45           sta $45                                  sta MINIDX
$C4BE: $A5 $44           lda $44                                  lda MAXIDX + 1
$C4C0: $85 $46           sta $46                                  sta MINIDX + 1
$C4C2: $A5 $FB           lda $FB                                  lda NXTLN
$C4C4: $85 $43           sta $43                                  sta MAXIDX
$C4C6: $A5 $FC           lda $FC                                  lda NXTLN + 1
$C4C8: $85 $44           sta $44                                  sta MAXIDX + 1
                                                  
$C4CA: $20 $90 $C5       jsr $C590                                jsr MOVEDOWN
                                                  
                                                                  ;
                                                                  ;   restore nxtln
                                                                  ;
$C4CD: $A0 $01           ldy #$01                                 SAVEZP +,NXTLN,2
$C4CF: $B9 $D9 $C4       lda $C4D9,y              
$C4D2: $99 $FB $00       sta $00FB,y              
$C4D5: $88               dey                      
$C4D6: $10 $F7           bpl $C4CF                
$C4D8: $60               rts                                      rts
                                                  
$C4D9: $00 $00           .db $00, $00             +               .word 0
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* MOVELINESUP                              *
                                                  ;*                                          *
                                                  ;*  move basic lines to add room            *
                                                  ;*                                          *
                                                  ;********************************************
                                                  MOVELINESUP
                                                                  ;
                                                                  ;   save nxtln
                                                                  ;
$C4DB: $A0 $01           ldy #$01                                 SAVEZP NXTLN,+,2
$C4DD: $B9 $FB $00       lda $00FB,y              
$C4E0: $99 $64 $C5       sta $C564,y              
$C4E3: $88               dey                      
$C4E4: $10 $F7           bpl $C4DD                
                                                  
                                                                  ;
                                                                  ;   set MINIDX to endptr
                                                                  ;
$C4E6: $A5 $FB           lda $FB                                  lda NXTLN
$C4E8: $85 $45           sta $45                                  sta MINIDX
$C4EA: $A5 $FC           lda $FC                                  lda NXTLN + 1
$C4EC: $85 $46           sta $46                                  sta MINIDX + 1
$C4EE: $18               clc                                      clc
$C4EF: $A5 $62           lda $62                                  lda LININS
$C4F1: $65 $45           adc $45                                  adc MINIDX
$C4F3: $85 $45           sta $45                                  sta MINIDX
$C4F5: $A9 $00           lda #$00                                 lda #0
$C4F7: $65 $46           adc $46                                  adc MINIDX + 1
$C4F9: $85 $46           sta $46                                  sta MINIDX + 1
                                                  
                                                                  ;
                                                                  ;   find out how many more bytes we need
                                                                  ;
$C4FB: $38               sec                                      sec
$C4FC: $A5 $61           lda $61                                  lda BCDLEN
$C4FE: $E5 $66           sbc $66                                  sbc LNUMLEN
$C500: $85 $59           sta $59                                  sta LASTIDX
                                                  
                                                                  ;
                                                                  ;   fix basic variables
                                                                  ;
$C502: $18               clc                                      clc
$C503: $65 $31           adc $31                                  adc STREND
$C505: $85 $31           sta $31                                  sta STREND
$C507: $A9 $00           lda #$00                                 lda #0
$C509: $65 $32           adc $32                                  adc STREND+1
$C50B: $85 $32           sta $32                                  sta STREND+1
                                                  
                                                                  ;
                                                                  ;   add to the line start pointers
                                                                  ;
                                                  -
$C50D: $A0 $00           ldy #$00                                 ldy #NXOFF
$C50F: $18               clc                                      clc
$C510: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C512: $85 $43           sta $43                                  sta MAXIDX
$C514: $65 $59           adc $59                                  adc LASTIDX
$C516: $91 $FB           sta ($FB),y                              sta (NXTLN),y
$C518: $C8               iny                                      iny
$C519: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C51B: $85 $44           sta $44                                  sta MAXIDX + 1
$C51D: $69 $00           adc #$00                                 adc #0
$C51F: $91 $FB           sta ($FB),y                              sta (NXTLN),y
                                                  
                                                                  ;
                                                                  ;   copy maxidx to nxtln
                                                                  ;
$C521: $A5 $43           lda $43                                  lda MAXIDX
$C523: $85 $FB           sta $FB                                  sta NXTLN
$C525: $A5 $44           lda $44                                  lda MAXIDX + 1
$C527: $85 $FC           sta $FC                                  sta NXTLN + 1
                                                  
                                                                  ;
                                                                  ;   check for end of basic
                                                                  ;
$C529: $20 $B1 $C5       jsr $C5B1                                jsr LASTLINE
$C52C: $D0 $DF           bne $C50D                                bne -
                                                  
                                                                  ;
                                                                  ;   figure out numbytes to move
                                                                  ;
$C52E: $38               sec                                      sec
$C52F: $A5 $43           lda $43                                  lda MAXIDX
$C531: $E5 $45           sbc $45                                  sbc MINIDX
$C533: $85 $22           sta $22                                  sta CURIDX
$C535: $A5 $44           lda $44                                  lda MAXIDX + 1
$C537: $E5 $46           sbc $46                                  sbc MINIDX + 1
$C539: $85 $23           sta $23                                  sta CURIDX + 1
                                                  
                                                                  ;
                                                                  ;   add EOL and end of basic marker
                                                                  ;
$C53B: $18               clc                                      clc
$C53C: $A5 $22           lda $22                                  lda CURIDX
$C53E: $69 $04           adc #$04                                 adc #4
$C540: $85 $22           sta $22                                  sta CURIDX
$C542: $A5 $23           lda $23                                  lda CURIDX + 1
$C544: $69 $00           adc #$00                                 adc #0
$C546: $85 $23           sta $23                                  sta CURIDX + 1
                                                  
                                                                  ;
                                                                  ;   set max to new dest address
                                                                  ;
$C548: $18               clc                                      clc
$C549: $A5 $45           lda $45                                  lda MINIDX
$C54B: $65 $59           adc $59                                  adc LASTIDX
$C54D: $85 $43           sta $43                                  sta MAXIDX
$C54F: $A5 $46           lda $46                                  lda MINIDX + 1
$C551: $69 $00           adc #$00                                 adc #0
$C553: $85 $44           sta $44                                  sta MAXIDX + 1
                                                  
$C555: $20 $66 $C5       jsr $C566                                jsr MOVEUP
                                                  
                                                                  ;
                                                                  ;   restore nxtln
                                                                  ;
$C558: $A0 $01           ldy #$01                                 SAVEZP +,NXTLN,2
$C55A: $B9 $64 $C5       lda $C564,y              
$C55D: $99 $FB $00       sta $00FB,y              
$C560: $88               dey                      
$C561: $10 $F7           bpl $C55A                
                                                  
$C563: $60               rts                                      rts
                                                  
$C564: $00 $00           .db $00, $00             +               .word 0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* Move memory up                           *
                                                  ;*                                          *
                                                  ;* FROM = source start address              *
                                                  ;*   TO = destination start address         *
                                                  ;* SIZE = number of bytes to move           *
                                                  ;*                                          *
                                                  ;********************************************
                                                  MOVEUP
$C566: $A6 $23           ldx $23                                  ldx SIZEH               ; the last byte must be moved first
$C568: $18               clc                                      clc                     ; start at the final pages of from and to
$C569: $8A               txa                                      txa
$C56A: $65 $46           adc $46                                  adc FROM + 1
$C56C: $85 $46           sta $46                                  sta FROM + 1
$C56E: $18               clc                                      clc
$C56F: $8A               txa                                      txa
$C570: $65 $44           adc $44                                  adc TO + 1
$C572: $85 $44           sta $44                                  sta TO + 1
$C574: $E8               inx                                      inx                     ; allows the use of bne after the dex below
$C575: $A4 $22           ldy $22                                  ldy SIZEL
$C577: $F0 $0E           beq $C587                                beq ++
$C579: $88               dey                                      dey                     ; move bytes on the last page first
$C57A: $F0 $07           beq $C583                                beq +
                                                  -
$C57C: $B1 $45           lda ($45),y                              lda (FROM),y
$C57E: $91 $43           sta ($43),y                              sta (TO),y
$C580: $88               dey                                      dey
$C581: $D0 $F9           bne $C57C                                bne -
                                                  +
$C583: $B1 $45           lda ($45),y                              lda (FROM),y            ; handle Y = 0 separately
$C585: $91 $43           sta ($43),y                              sta (TO),y
                                                  +
$C587: $88               dey                                      dey
$C588: $C6 $46           dec $46                                  dec FROM + 1            ; move the next page (if any)
$C58A: $C6 $44           dec $44                                  dec TO + 1
$C58C: $CA               dex                                      dex
$C58D: $D0 $ED           bne $C57C                                bne -
                                                  
$C58F: $60               rts                                      rts
                                                  
                                                  ;********************************************
                                                  ; Move memory down                          *
                                                  ;                                           *
                                                  ; FROM = source start address               *
                                                  ;   TO = destination start address          *
                                                  ; SIZE = number of bytes to move            *
                                                  ;                                           *
                                                  ;********************************************
                                                  MOVEDOWN
$C590: $A0 $00           ldy #$00                                 ldy #0
$C592: $A6 $23           ldx $23                                  ldx SIZEH
$C594: $F0 $0E           beq $C5A4                                beq +
                                                  -
$C596: $B1 $45           lda ($45),y                              lda (FROM),y            ;   move a page at a time
$C598: $91 $43           sta ($43),y                              sta (TO),y
$C59A: $C8               iny                                      iny
$C59B: $D0 $F9           bne $C596                                bne -
$C59D: $E6 $46           inc $46                                  inc FROM + 1
$C59F: $E6 $44           inc $44                                  inc TO + 1
$C5A1: $CA               dex                                      dex
$C5A2: $D0 $F2           bne $C596                                bne -
                                                  +
$C5A4: $A6 $22           ldx $22                                  ldx SIZEL
$C5A6: $F0 $08           beq $C5B0                                beq +
                                                  -
$C5A8: $B1 $45           lda ($45),y                              lda (FROM),y            ;   move the remaining bytes
$C5AA: $91 $43           sta ($43),y                              sta (TO),y
$C5AC: $C8               iny                                      iny
$C5AD: $CA               dex                                      dex
$C5AE: $D0 $F8           bne $C5A8                                bne -
                                                  +
$C5B0: $60               rts                                      rts
                                                  

Processing util.asm

                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  LASTLINE                                *
                                                  ;*                                          *
                                                  ;*  set the Z flag if we are at the end OF  *
                                                  ;*  basic program.                          *
                                                  ;*  nxtln must point to current line        *
                                                  ;*                                          *
                                                  ;*  destroys a,y                            *
                                                  ;*                                          *
                                                  ;********************************************
                                                  LASTLINE
                                                                  ;
                                                                  ;   load the pointer to next line
                                                                  ;   00 00 is the end of program
                                                                  ;
$C5B1: $A0 $00           ldy #$00                                 ldy #NXOFF
$C5B3: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
$C5B5: $D0 $03           bne $C5BA                                bne +
$C5B7: $C8               iny                                      iny
$C5B8: $B1 $FB           lda ($FB),y                              lda (NXTLN),y
                                                  +
$C5BA: $60               rts                                      rts
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  BINBCD16                                *
                                                  ;*                                          *
                                                  ;*  convert 16 bit number to bcd and a      *
                                                  ;*   string                                 *
                                                  ;*  bnvar must contain number to convert    *
                                                  ;*  bcd on exit contains bcd number 3 bytes *
                                                  ;*                                          *
                                                  ;*  bcdstr on exit contains bcd string      *
                                                  ;*                                          *
                                                  ;*  destroys    a,y                         *
                                                  ;*                                          *
                                                  ;********************************************
                                                  BINBCD16
                                                                  ;
                                                                  ;   set decimal code
                                                                  ;   clear result
                                                                  ;
$C5BB: $F8               sed                                      sed
$C5BC: $A9 $00           lda #$00                                 lda #0
$C5BE: $85 $4D           sta $4D                                  sta BCD
$C5C0: $85 $4E           sta $4E                                  sta BCD + 1
$C5C2: $85 $4F           sta $4F                                  sta BCD + 2
                                                  
                                                                  ;
                                                                  ;   loop 16 bits
                                                                  ;
$C5C4: $A0 $10           ldy #$10                                 ldy #16
                                                  -
$C5C6: $06 $4B           asl $4B                                  asl BNVAR               ;   shift bnvar left by 1
$C5C8: $26 $4C           rol $4C                                  rol BNVAR + 1
$C5CA: $A5 $4D           lda $4D                                  lda BCD                 ;   shift into bcd
$C5CC: $65 $4D           adc $4D                                  adc BCD
$C5CE: $85 $4D           sta $4D                                  sta BCD
$C5D0: $A5 $4E           lda $4E                                  lda BCD + 1             ;   shift into bcd + 1
$C5D2: $65 $4E           adc $4E                                  adc BCD + 1
$C5D4: $85 $4E           sta $4E                                  sta BCD + 1
$C5D6: $A5 $4F           lda $4F                                  lda BCD + 2             ;   shift into bcd + 2
$C5D8: $65 $4F           adc $4F                                  adc BCD + 2
$C5DA: $85 $4F           sta $4F                                  sta BCD + 2
                                                  
$C5DC: $88               dey                                      dey                     ;   check for end of loop
$C5DD: $D0 $E7           bne $C5C6                                bne -
                                                  
                                                                  ;
                                                                  ;   clear decimal mode
                                                                  ;
$C5DF: $D8               cld                                      cld
                                                  
                                                                  ;
                                                                  ;   convert bcd 3 bytes to a string
                                                                  ;
$C5E0: $A5 $4D           lda $4D                                  BCD2STR BCD + 0, BCDSTR + 3
$C5E2: $29 $F0           and #$F0                 
$C5E4: $4A               lsr                      
$C5E5: $4A               lsr                      
$C5E6: $4A               lsr                      
$C5E7: $4A               lsr                      
$C5E8: $09 $30           ora #$30                 
$C5EA: $85 $3E           sta $3E                  
$C5EC: $A5 $4D           lda $4D                  
$C5EE: $29 $0F           and #$0F                 
$C5F0: $09 $30           ora #$30                 
$C5F2: $85 $3F           sta $3F                  
$C5F4: $A5 $4E           lda $4E                                  BCD2STR BCD + 1, BCDSTR + 1
$C5F6: $29 $F0           and #$F0                 
$C5F8: $4A               lsr                      
$C5F9: $4A               lsr                      
$C5FA: $4A               lsr                      
$C5FB: $4A               lsr                      
$C5FC: $09 $30           ora #$30                 
$C5FE: $85 $3C           sta $3C                  
$C600: $A5 $4E           lda $4E                  
$C602: $29 $0F           and #$0F                 
$C604: $09 $30           ora #$30                 
$C606: $85 $3D           sta $3D                  
$C608: $A5 $4F           lda $4F                                  lda BCD + 2
$C60A: $29 $0F           and #$0F                                 and #$0F
$C60C: $09 $30           ora #$30                                 ora #'0'
$C60E: $85 $3B           sta $3B                                  sta BCDSTR
$C610: $60               rts                                      rts
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  BCDLENGTH                               *
                                                  ;*                                          *
                                                  ;*  get length of BCDSTR                    *
                                                  ;*  store result in BCDLEN                  *
                                                  ;*                                          *
                                                  ;*  destroys    a,y                         *
                                                  ;*                                          *
                                                  ;********************************************
                                                  BCDLENGTH
                                                                  ;
                                                                  ;   loop through 5 chars
                                                                  ;
$C611: $A0 $00           ldy #$00                                 ldy #0
$C613: $84 $61           sty $61                                  sty BCDLEN
                                                  -
$C615: $B9 $3B $00       lda $003B,y                              lda BCDSTR,y
$C618: $C9 $30           cmp #$30                                 cmp #'0'
$C61A: $D0 $08           bne $C624                                bne +
                                                  
$C61C: $C0 $04           cpy #$04                                 cpy #4
$C61E: $F0 $04           beq $C624                                beq +
                                                  
$C620: $A6 $61           ldx $61                                  ldx BCDLEN
$C622: $F0 $0A           beq $C62E                                beq ++
                                                  +
$C624: $84 $61           sty $61                                  sty BCDLEN
$C626: $A9 $05           lda #$05                                 lda #5
$C628: $38               sec                                      sec
$C629: $E5 $61           sbc $61                                  sbc BCDLEN
$C62B: $85 $61           sta $61                                  sta BCDLEN
$C62D: $60               rts                                      rts
                                                  +
$C62E: $C8               iny                                      iny
$C62F: $D0 $E4           bne $C615                                bne -
                                                  

Processing debug.asm

                                                  
                                                  .ifdef debug
                                                  
                                                              .macro DMP_BYT
                                                  
                                                              PUSHAY
                                                  
                                                              jsr DUMP_NEWLINE
                                                  
                                                              lda #>@1
                                                              ldy #<@1
                                                              jsr DUMP_STR
                                                              lda @2       
                                                              jsr DUMP_BYTE
                                                  
                                                              POPAY            
                                                              .endm
                                                         
                                                              .macro DMP_WRD
                                                  
                                                              PUSHAY
                                                  
                                                              jsr DUMP_NEWLINE
                                                  
                                                              lda #>@1
                                                              ldy #<@1
                                                              jsr DUMP_STR
                                                              lda @2 
                                                              ldy @2 + 1
                                                              jsr DUMP_BYTE
                                                  
                                                              POPAY
                                                              
                                                              .endm
                                                      
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_REGISTERS                           *
                                                  ;*                                          *
                                                  ;*  print values of all registers           *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_REGISTER
                                                                  php
                                                  
                                                                  sta ACC
                                                                  stx XREG
                                                                  sty YREG
                                                  
                                                                  pla
                                                                  sta PSTATUS
                                                  
                                                                  tsx
                                                                  inx                     ;   account for pushed return address
                                                                  inx
                                                                  stx SP
                                                  
                                                                  ;
                                                                  ;   get the return address
                                                                  ;
                                                                  pla
                                                                  sta PC_ORIGINAL
                                                                  pla
                                                                  sta PC_ORIGINAL + 1
                                                  
                                                                  cld
                                                  
                                                                  sec                     ;   we need to fix pc on stack
                                                                  lda PC_ORIGINAL
                                                                  sbc #02
                                                                  sta PC
                                                                  lda PC_ORIGINAL + 1
                                                                  sbc #0
                                                                  sta PC + 1
                                                  
                                                                  ;
                                                                  ;   dump a new line
                                                                  ;
                                                                  jsr DUMP_NEWLINE
                                                                  bne +
                                                  
                                                  -               .byte " SP=",0
                                                  -               .byte " Y=",0
                                                  -               .byte " X=",0
                                                  -               .byte " A=",0
                                                  -               .byte " PC=",0
                                                  
                                                                  ;
                                                                  ;   Program counter
                                                                  ;
                                                  +
                                                                  DMP_WRD -,PC
                                                  
                                                                  ;
                                                                  ;   A Register
                                                                  ;
                                                                  DMP_BYT --,ACC
                                                  
                                                                  ;
                                                                  ;   X Register
                                                                  ;
                                                                  DMP_BYT ---,XREG
                                                  
                                                                  ;
                                                                  ;   Y Register
                                                                  ;
                                                                  DMP_BYT ----,YREG
                                                  
                                                                  ;
                                                                  ;   Stack Pointer
                                                                  ;
                                                                  DMP_BYT -----,SP + 2
                                                  
                                                                  ;
                                                                  ;   pstatus flag
                                                                  jsr DUMP_SPACE          ;   dump pstatus flags
                                                                  lda #$80                ;   set mask forprocessor
                                                                  sta STATTMP
                                                                  ldy #0
                                                                  ;
                                                                  ; fall through
                                                                  ;
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_STATUS                              *
                                                  ;*                                          *
                                                  ;*  print status register                   *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_STATUS
                                                                  lda PSTATUS
                                                                  and STATTMP
                                                                  bne +
                                                  
                                                                  lda #'.'
                                                                  bne ++
                                                  +
                                                                  lda DUMP_BITS,y
                                                  +
                                                                  jsr CHROUT
                                                                  lsr STATTMP
                                                                  iny
                                                                  cpy #8                  ;   is this the last bit?
                                                                  bne DUMP_STATUS
                                                  
                                                                  jsr DUMP_NEWLINE
                                                                                          ;   prepare for exit
                                                                                          ;   push orginal return address on stack
                                                                  lda PC_ORIGINAL + 1
                                                                  pha
                                                                  lda PC_ORIGINAL
                                                                  pha
                                                  
                                                                  lda PSTATUS             ;   push original processor status
                                                                  pha
                                                                  lda ACC                 ;   restore accumulator
                                                                  ldx XREG                ;   restore x
                                                                  ldy YREG                ;   restore y
                                                                  plp                     ;   pull processor status
                                                                  rts                     ;   exit to caller
                                                  
                                                  
                                                  ;   symbolic codes for pstatus register bits
                                                  
                                                  DUMP_BITS       .byte "NV.BDIZC"
                                                  PC_ORIGINAL     .word 0
                                                  PC              .word 0
                                                  ACC             .byte 0
                                                  XREG            .byte 0
                                                  YREG            .byte 0
                                                  SP              .byte 0
                                                  PSTATUS         .byte 0
                                                  STATTMP         .byte 0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_LI                                  *
                                                  ;*                                          *
                                                  ;*  print line number                       *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_LI
                                                                  DMP_BYT +,LININS
                                                                  rts
                                                  +               .byte " LI=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_LN                                  *
                                                  ;*                                          *
                                                  ;*  print line number                       *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_LN
                                                                  DMP_WRD +,LNUM
                                                                  rts
                                                  +               .byte " LN=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_MX                                  *
                                                  ;*                                          *
                                                  ;*  print max                               *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_MX
                                                                  DMP_WRD +,MAXIDX
                                                                  rts
                                                  +               .byte " MX=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_MN                                  *
                                                  ;*                                          *
                                                  ;*  print min                               *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_MN
                                                                  DMP_WRD +,MINIDX
                                                                  rts
                                                  +               .byte " MN=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_TS                                  *
                                                  ;*                                          *
                                                  ;*  print table size                        *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_TS
                                                                  DMP_WRD +,TBLSZ
                                                                  rts
                                                  +               .byte " TS=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_I                                   *
                                                  ;*                                          *
                                                  ;*  print index, tablentry                  *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_I
                                                                  DMP_WRD +,CURIDX
                                                                  rts
                                                  +               .byte " I=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_TP                                  *
                                                  ;*                                          *
                                                  ;*  print TablePointer                      *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_TP
                                                                  DMP_WRD +,TBLPTR
                                                                  rts
                                                  +               .byte " TP=", 0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_TE                                  *
                                                  ;*                                          *
                                                  ;*  print TableEntry                        *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_TE
                                                                  PUSHAY
                                                  
                                                                  lda #>+
                                                                  ldy #<+
                                                                  jsr DUMP_STR
                                                                  ldy #0
                                                                  lda (TBLPTR),y
                                                                  pha
                                                                  iny
                                                                  lda (TBLPTR),y
                                                                  tay
                                                                  pla
                                                                  jsr DUMP_WORD
                                                                  jsr DUMP_NEWLINE
                                                  
                                                                  POPAY
                                                                  rts
                                                  +               .byte " TE=", 0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_NXTLN                               *
                                                  ;*                                          *
                                                  ;*  print NXTLN=xxxx                        *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_NXTLN
                                                                  DMP_WRD +,NXTLN
                                                                  rts
                                                  +               .byte " NXTLN=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_FOUNDLINE                           *
                                                  ;*                                          *
                                                  ;*  print FOUND LINE                        *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_FOUNDLINE
                                                                  PUSHAY
                                                  
                                                                  lda #>+
                                                                  ldy #<+
                                                                  jsr DUMP_STR
                                                  
                                                                  POPAY
                                                                  rts
                                                  +               .byte "FOUND LINE ",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_LENGTH                              *
                                                  ;*                                          *
                                                  ;*  print LENGTH=                           *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_LENGTH
                                                                  PUSHAY
                                                  
                                                                  lda #>+
                                                                  ldy #<+
                                                                  jsr DUMP_STR
                                                  
                                                                  POPAY
                                                                  rts
                                                  +               .byte "LEN=",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_STAR                                *
                                                  ;*                                          *
                                                  ;*  print *                                 *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_STAR
                                                                  PUSHAY
                                                  
                                                                  lda #>+
                                                                  ldy #<+
                                                                  jsr DUMP_STR
                                                  
                                                                  POPAY
                                                                  rts
                                                  +               .byte "      *",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_PLUS                                *
                                                  ;*                                          *
                                                  ;*  print +                                 *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_PLUS
                                                                  PUSHAY
                                                  
                                                                  lda #>+
                                                                  ldy #<+
                                                                  jsr DUMP_STR
                                                  
                                                                  POPAY
                                                                  rts
                                                  +               .byte "      +",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_MINUS                               *
                                                  ;*                                          *
                                                  ;*  print -                                 *
                                                  ;*                                          *
                                                  ;*  destroys nothing                        *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_MINUS
                                                                  PUSHAY
                                                  
                                                                  lda #>+
                                                                  ldy #<+
                                                                  jsr DUMP_STR
                                                  
                                                                  POPAY
                                                                  rts
                                                  +               .byte "      -",0
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_NEWLINE                             *
                                                  ;*                                          *
                                                  ;*  print 0x0D                              *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_NEWLINE
                                                                  lda #13
                                                                  jmp CHROUT
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_SPACE                               *
                                                  ;*                                          *
                                                  ;*  print ' '                               *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_SPACE
                                                                  lda #' '
                                                                  jmp CHROUT
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_EQUALS                              *
                                                  ;*                                          *
                                                  ;*  print =                                 *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_EQUALS
                                                                  lda #'='
                                                                  jmp CHROUT
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_WORD                                *
                                                  ;*                                          *
                                                  ;*  print number in a(lo) y (hi) in hex     *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_WORD
                                                                  pha
                                                                  tya
                                                                  jsr DUMP_BYTE
                                                                  pla
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_BYTE                                *
                                                  ;*                                          *
                                                  ;*  print number in a  in hex               *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_BYTE
                                                                  pha
                                                                  lsr
                                                                  lsr
                                                                  lsr
                                                                  lsr
                                                                  jsr DUMP_NYBBLE
                                                                  pla
                                                                  and #$0F
                                                                  ; fall through
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_NYBBLE                              *
                                                  ;*                                          *
                                                  ;*  converts the 4 bit nybble in a to       *
                                                  ;*  an ascii character and prints it        *
                                                  ;*                                          *
                                                  ;*  destroys a                              *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_NYBBLE
                                                                  ora #'0'
                                                                  cmp #'9' + 1
                                                                  bcc +
                                                                  adc #'A' - ('9' + 2)
                                                  +
                                                                  jmp CHROUT
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;* DUMP_STR                                 *
                                                  ;*                                          *
                                                  ;*  print string pointed to by y and a      *
                                                  ;*  a low byte y high byte null byte marks  *
                                                  ;*  end of string                           *
                                                  ;*  destroys a,y                            *
                                                  ;*                                          *
                                                  ;********************************************
                                                  DUMP_STR
                                                                  sty DUMPSTR
                                                                  sta DUMPSTR + 1
                                                                  ldy #0
                                                  -
                                                                  lda (DUMPSTR),y
                                                                  beq +
                                                                  jsr CHROUT
                                                                  iny
                                                                  bne -
                                                  +
                                                                  rts
                                                  
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  PRNTLN                                  *
                                                  ;*                                          *
                                                  ;*  print the current line                  *
                                                  ;*  nxtln must be current line              *
                                                  ;*                                          *
                                                  ;*  destroys    a,y                         *
                                                  ;*                                          *
                                                  ;********************************************
                                                  PRNTLN
                                                                  ;
                                                                  ;   get current line number
                                                                  ;   store in bnvar
                                                                  ;
                                                                  ldy #LNOFF
                                                                  lda (NXTLN),y
                                                                  sta BNVAR
                                                                  iny
                                                                  lda (NXTLN),y
                                                                  sta BNVAR+1
                                                                  ;
                                                                  ;   fall through to printnum
                                                                  ;
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  PRINTNUM                                *
                                                  ;*                                          *
                                                  ;*  print number in bnvar in decimal        *
                                                  ;*  with a trailing space                   *
                                                  ;*                                          *
                                                  ;*  destroys    a,y,x                       *
                                                  ;*                                          *
                                                  ;********************************************
                                                  PRINTNUM
                                                                  ;
                                                                  ;   convert to bcd and string
                                                                  ;
                                                                  jsr BINBCD16
                                                  
                                                                  ;
                                                                  ;   fall through to printnum
                                                                  ;
                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  PRINTBCDSTR                             *
                                                  ;*                                          *
                                                  ;*  print number in bcdstr in decimal       *
                                                  ;*  with a trailing space                   *
                                                  ;*                                          *
                                                  ;*  destroys    a,y,x                       *
                                                  ;*                                          *
                                                  ;********************************************
                                                  PRINTBCDSTR
                                                                  ;
                                                                  ;   loop through 5 chars
                                                                  ;
                                                                  ldy #0
                                                                  sty LDZFLG
                                                  -
                                                                  lda BCDSTR,y
                                                                  cmp #'0'
                                                                  bne +
                                                  
                                                                  cpy #4
                                                                  beq +
                                                  
                                                                  ldx LDZFLG
                                                                  beq ++
                                                  +
                                                                  jsr CHROUT
                                                                  inc LDZFLG
                                                  +
                                                                  iny
                                                                  cpy #5
                                                                  bne -
                                                  
                                                                  lda #' '
                                                  
                                                                  jmp CHROUT
                                                  
                                                  .endif

Processing storage.asm

                                                  ;********************************************
                                                  ;*                                          *
                                                  ;*  STORAGE                                 *
                                                  ;*                                          *
                                                  ;********************************************
$C631: $00               .db $00                  R6510SV         .byte 0
$C632: $00 $00           .db $00, $00             LSTART          .word 0
$C634: $00 $00           .db $00, $00             IGONE_SV        .word 0
$C636: $36 $C6           .db $36, $C6             TBL             .word *
                                                  
